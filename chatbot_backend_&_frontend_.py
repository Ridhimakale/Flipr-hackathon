# -*- coding: utf-8 -*-
"""Chatbot_Backend_&_Frontend_.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W5D5vGuzdkczrqOYaeg1TALWvp0PaMG3
"""

!pip install google-generativeai firebase-admin python-dotenv



# First install required packages:
# !pip install google-generativeai firebase-admin python-dotenv

import json
import time
import os
from datetime import datetime
from typing import Dict, List, Optional
import google.generativeai as genai
import firebase_admin
from firebase_admin import credentials, firestore

class GeminiFirebaseChatbot:
    def __init__(self, gemini_api_key: str, firebase_credentials_path: str = None):
        # Initialize Gemini API
        genai.configure(api_key=gemini_api_key)
        self.model = genai.GenerativeModel('gemini-pro')

        # Initialize Firebase
        if firebase_credentials_path:
            cred = credentials.Certificate(firebase_credentials_path)
        else:
            # For demo purposes, using default credentials
            # In production, use proper service account key
            try:
                cred = credentials.ApplicationDefault()
            except:
                print("âš ï¸  Firebase credentials not found. Using local storage fallback.")
                self.db = None

        if not firebase_admin._apps:
            try:
                firebase_admin.initialize_app(cred)
                self.db = firestore.client()
                print("âœ… Firebase connected successfully!")
            except Exception as e:
                print(f"âš ï¸  Firebase connection failed: {e}")
                print("ğŸ“ Using local storage fallback.")
                self.db = None
        else:
            self.db = firestore.client()

        # Local storage fallback
        self.local_tickets = []
        self.messages = []
        self.session_id = f"session_{int(time.time())}"

        # Enhanced Knowledge Base for Gemini context
        self.KNOWLEDGE_BASE = {
            "company_info": {
                "name": "TechStore Pro",
                "shipping_policy": "Standard: 3-5 days ($5.99), Express: 1-2 days ($12.99), Free shipping over $50",
                "return_policy": "30-day return policy for unopened items",
                "contact": "Email: support@techstore.com, Phone: 1-800-TECH-HELP",
                "business_hours": "9AM-9PM EST",
                "website": "techstore.com"
            }
        }

        # Ticket classification system
        self.TICKET_CATEGORIES = {
            "delivery_issue": {"priority": "medium", "emoji": "ğŸ“¦"},
            "product_defect": {"priority": "high", "emoji": "âš ï¸"},
            "billing_issue": {"priority": "high", "emoji": "ğŸ’³"},
            "account_issue": {"priority": "medium", "emoji": "ğŸ‘¤"},
            "technical_issue": {"priority": "medium", "emoji": "ğŸ”§"},
            "general_inquiry": {"priority": "low", "emoji": "â“"}
        }

        # Initialize chat
        self.add_message("assistant", "ğŸ‘‹ Hi! I'm your AI Customer Support Assistant powered by Gemini. I can help with orders, returns, billing, and technical issues. What can I help you with today?")

    def add_message(self, role: str, content: str):
        """Add message to conversation history"""
        message = {
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat(),
            "session_id": self.session_id
        }
        self.messages.append(message)

    def classify_issue(self, user_message: str) -> Dict:
        """Use Gemini to classify the user's issue"""
        classification_prompt = f"""
        Analyze this customer support message and classify it:
        Message: "{user_message}"

        Return ONLY a JSON object with these fields:
        {{
            "category": "delivery_issue|product_defect|billing_issue|account_issue|technical_issue|general_inquiry",
            "needs_ticket": true/false,
            "urgency": "low|medium|high",
            "summary": "brief summary of the issue"
        }}

        Guidelines:
        - needs_ticket: true if it's a complaint, problem, or requires human intervention
        - needs_ticket: false for simple questions or information requests
        - urgency: high for billing, broken products, security issues
        """

        try:
            response = self.model.generate_content(classification_prompt)
            # Parse JSON from response
            classification = json.loads(response.text.strip())
            return classification
        except Exception as e:
            print(f"âš ï¸  Classification error: {e}")
            # Fallback classification
            return {
                "category": "general_inquiry",
                "needs_ticket": False,
                "urgency": "low",
                "summary": "General customer inquiry"
            }

    def create_firebase_ticket(self, user_message: str, classification: Dict) -> str:
        """Create and store ticket in Firebase"""
        ticket_data = {
            "id": f"TKT{int(time.time())}",
            "user_message": user_message,
            "category": classification["category"],
            "priority": classification["urgency"],
            "summary": classification["summary"],
            "status": "open",
            "created_at": datetime.now().isoformat(),
            "session_id": self.session_id,
            "needs_human_review": classification["urgency"] == "high"
        }

        try:
            if self.db:
                # Store in Firebase
                doc_ref = self.db.collection('support_tickets').document(ticket_data["id"])
                doc_ref.set(ticket_data)
                print(f"âœ… Ticket {ticket_data['id']} saved to Firebase")
            else:
                # Store locally as fallback
                self.local_tickets.append(ticket_data)
                print(f"ğŸ“ Ticket {ticket_data['id']} saved locally")

            # Format response
            category_info = self.TICKET_CATEGORIES.get(classification["category"], {"emoji": "ğŸ«"})
            priority_emoji = {"low": "ğŸŸ¢", "medium": "ğŸŸ¡", "high": "ğŸ”´"}[classification["urgency"]]

            response_time = {
                "low": "24-48 hours",
                "medium": "4-12 hours",
                "high": "1-4 hours"
            }[classification["urgency"]]

            return f"""
ğŸ« **Support Ticket Created**

{category_info['emoji']} **Ticket ID:** {ticket_data['id']}
{priority_emoji} **Priority:** {classification['urgency'].title()}
ğŸ“‹ **Category:** {classification['category'].replace('_', ' ').title()}
ğŸ“ **Summary:** {classification['summary']}

â° **Expected Response Time:** {response_time}
ğŸ“§ You'll receive updates via email
ğŸ”” Ticket status: Open

We'll get this resolved for you quickly!
            """.strip()

        except Exception as e:
            print(f"âŒ Error creating ticket: {e}")
            return "âŒ Sorry, there was an error creating your support ticket. Please try again or contact us directly."

    def get_gemini_response(self, user_message: str, classification: Dict) -> str:
        """Get intelligent response from Gemini"""

        # Build context for Gemini
        context = f"""
        You are a friendly, professional customer support AI assistant for {self.KNOWLEDGE_BASE['company_info']['name']}.

        Company Information:
        - Shipping: {self.KNOWLEDGE_BASE['company_info']['shipping_policy']}
        - Returns: {self.KNOWLEDGE_BASE['company_info']['return_policy']}
        - Contact: {self.KNOWLEDGE_BASE['company_info']['contact']}
        - Hours: {self.KNOWLEDGE_BASE['company_info']['business_hours']}
        - Website: {self.KNOWLEDGE_BASE['company_info']['website']}

        Customer's issue classification:
        - Category: {classification['category']}
        - Urgency: {classification['urgency']}
        - Summary: {classification['summary']}

        Guidelines:
        - Be empathetic and helpful
        - Provide specific, actionable solutions
        - Use emojis appropriately
        - Keep responses concise but informative
        - If you can't solve it completely, acknowledge and offer next steps

        Customer message: "{user_message}"

        Provide a helpful response:
        """

        try:
            response = self.model.generate_content(context)
            return response.text.strip()
        except Exception as e:
            print(f"âš ï¸  Gemini API error: {e}")
            # Fallback response
            return f"I understand you're asking about {classification['summary']}. Let me help you with that! For immediate assistance, you can contact us at {self.KNOWLEDGE_BASE['company_info']['contact']} or visit {self.KNOWLEDGE_BASE['company_info']['website']}."

    def chat(self, user_input: str) -> str:
        """Main chat function with Gemini AI and Firebase integration"""
        # Add user message
        self.add_message("user", user_input)

        print("ğŸ¤– Analyzing your message...")

        # Classify the issue using Gemini
        classification = self.classify_issue(user_input)

        response = ""

        # Create ticket if needed
        if classification["needs_ticket"]:
            print("ğŸ« Creating support ticket...")
            ticket_response = self.create_firebase_ticket(user_input, classification)
            response += ticket_response + "\n\n"

        # Get AI response from Gemini
        print("ğŸ§  Generating response...")
        ai_response = self.get_gemini_response(user_input, classification)
        response += ai_response

        # Add assistant response
        self.add_message("assistant", response)

        return response

    def get_tickets_from_firebase(self) -> List[Dict]:
        """Retrieve tickets from Firebase"""
        tickets = []

        try:
            if self.db:
                # Get tickets from Firebase
                docs = self.db.collection('support_tickets').order_by('created_at', direction=firestore.Query.DESCENDING).limit(20).stream()

                for doc in docs:
                    ticket_data = doc.to_dict()
                    tickets.append(ticket_data)

                print(f"ğŸ“Š Retrieved {len(tickets)} tickets from Firebase")
            else:
                # Use local tickets
                tickets = sorted(self.local_tickets, key=lambda x: x['created_at'], reverse=True)
                print(f"ğŸ“ Retrieved {len(tickets)} tickets from local storage")

        except Exception as e:
            print(f"âŒ Error retrieving tickets: {e}")
            tickets = self.local_tickets

        return tickets

    def show_tickets(self):
        """Display support tickets"""
        tickets = self.get_tickets_from_firebase()

        if not tickets:
            print("ğŸ“‹ No support tickets found.\n")
            return

        print("ğŸ« === SUPPORT TICKETS ===")
        open_tickets = [t for t in tickets if t['status'] == 'open']
        print(f"ğŸ“Š Total: {len(tickets)} | Open: {len(open_tickets)}")
        print("-" * 60)

        for ticket in tickets[:10]:  # Show last 10 tickets
            category_info = self.TICKET_CATEGORIES.get(ticket['category'], {"emoji": "ğŸ«"})
            priority_emoji = {"low": "ğŸŸ¢", "medium": "ğŸŸ¡", "high": "ğŸ”´"}[ticket['priority']]
            status_emoji = "ğŸŸ¢" if ticket['status'] == 'resolved' else "ğŸ”´"

            print(f"{category_info['emoji']} #{ticket['id']} - {ticket['summary']}")
            print(f"   {priority_emoji} Priority: {ticket['priority'].title()} | {status_emoji} Status: {ticket['status'].title()}")
            print(f"   ğŸ“… Created: {datetime.fromisoformat(ticket['created_at']).strftime('%Y-%m-%d %H:%M')}")
            print(f"   ğŸ’¬ Message: {ticket['user_message'][:50]}...")
            print()

    def show_conversation(self):
        """Display conversation history"""
        print("ğŸ’¬ === CONVERSATION HISTORY ===")
        print("-" * 50)

        for msg in self.messages[-10:]:  # Show last 10 messages
            role_emoji = "ğŸ¤–" if msg['role'] == 'assistant' else "ğŸ‘¤"
            role_name = "Assistant" if msg['role'] == 'assistant' else "You"
            timestamp = datetime.fromisoformat(msg['timestamp']).strftime('%H:%M')

            print(f"{role_emoji} {role_name} ({timestamp}):")
            print(f"   {msg['content'][:100]}...")
            print()

def setup_credentials():
    """Help user set up API credentials"""
    print("ğŸ”‘ === API SETUP REQUIRED ===")
    print("\n1ï¸âƒ£  GEMINI API KEY:")
    print("   â€¢ Go to https://ai.google.dev/")
    print("   â€¢ Get your free API key")
    print("   â€¢ Enter it below")

    print("\n2ï¸âƒ£  FIREBASE SETUP (Optional):")
    print("   â€¢ Go to https://console.firebase.google.com/")
    print("   â€¢ Create a new project")
    print("   â€¢ Enable Firestore Database")
    print("   â€¢ Download service account key (optional)")

    print("\n" + "="*50)

    gemini_key = input("ğŸ”‘ Enter your Gemini API key: ").strip()

    if not gemini_key:
        print("âŒ Gemini API key is required!")
        return None, None

    firebase_path = input("ğŸ”¥ Firebase credentials path (press Enter to skip): ").strip()
    firebase_path = firebase_path if firebase_path else None

    return gemini_key, firebase_path

def run_chatbot():
    """Run the enhanced chatbot"""
    print("ğŸ¤– === GEMINI + FIREBASE CUSTOMER SUPPORT ===")

    # Setup credentials
    gemini_key, firebase_path = setup_credentials()
    if not gemini_key:
        return

    try:
        bot = GeminiFirebaseChatbot(gemini_key, firebase_path)
    except Exception as e:
        print(f"âŒ Failed to initialize chatbot: {e}")
        return

    print("\nğŸ’¡ Commands:")
    print("   â€¢ Type your questions normally")
    print("   â€¢ 'tickets' - View support tickets")
    print("   â€¢ 'history' - View conversation history")
    print("   â€¢ 'clear' - Clear screen")
    print("   â€¢ 'quit' - Exit chatbot")
    print("=" * 50)
    print()

    # Show welcome message
    print("ğŸ¤– AI Assistant:")
    print(f"   {bot.messages[0]['content']}")
    print()

    while True:
        try:
            user_input = input("ğŸ‘¤ You: ").strip()

            if not user_input:
                continue

            if user_input.lower() == 'quit':
                print("\nğŸ‘‹ Thank you for using our AI Customer Support! Have a great day!")
                break
            elif user_input.lower() == 'tickets':
                print()
                bot.show_tickets()
                continue
            elif user_input.lower() == 'history':
                print()
                bot.show_conversation()
                continue
            elif user_input.lower() == 'clear':
                print("\n" * 50)
                continue

            # Process with AI
            print()
            response = bot.chat(user_input)
            print("ğŸ¤– AI Assistant:")
            print(f"   {response}")
            print()

        except KeyboardInterrupt:
            print("\n\nğŸ‘‹ Chat interrupted. Goodbye!")
            break
        except Exception as e:
            print(f"\nâŒ Error: {e}")
            print("Please try again.\n")

# Run the enhanced chatbot
if __name__ == "__main__":
    run_chatbot()

import json
import random
import time
from datetime import datetime
from typing import Dict, List, Optional

class CustomerSupportChatbot:
    def __init__(self):
        self.tickets = []
        self.messages = []
        self.session_id = f"session_{int(time.time())}"

        # Knowledge Base
        self.KNOWLEDGE_BASE = {
            "track_order": {
                "response": "ğŸ” **Track Your Order**\nVisit example.com/track and enter your order number. You'll get real-time updates on your shipment status.\n\nğŸ“± You can also track via:\nâ€¢ Mobile app\nâ€¢ SMS updates\nâ€¢ Email notifications",
                "keywords": ["track", "order", "shipment", "delivery status", "where is my order", "tracking"]
            },
            "return": {
                "response": "ğŸ”„ **Return Policy**\nWe offer a 30-day return policy for unopened items.\n\nğŸ“‹ Return Process:\nâ€¢ Visit example.com/returns\nâ€¢ Print return label\nâ€¢ Package securely\nâ€¢ Drop off at any carrier location\n\nğŸ’° Refunds processed within 5-7 business days",
                "keywords": ["return", "refund", "exchange", "send back", "money back"]
            },
            "contact": {
                "response": "ğŸ“ **Contact Support**\nâ€¢ Email: support@example.com\nâ€¢ Phone: 1-800-HELP (24/7)\nâ€¢ Live Chat: Available 9AM-9PM EST\nâ€¢ Social Media: @ExampleSupport\n\nâ° Average response times:\nâ€¢ Chat: Under 2 minutes\nâ€¢ Email: Within 4 hours\nâ€¢ Phone: Immediate",
                "keywords": ["contact", "phone", "email", "support", "help", "call", "speak"]
            },
            "password": {
                "response": "ğŸ” **Password Reset**\nReset your password at example.com/forgot-password\n\nğŸ”‘ Steps:\n1. Enter your email\n2. Check for reset email (check spam folder)\n3. Click reset link\n4. Create new strong password\n\nğŸ’¡ Password tips: Use 8+ characters, mix letters/numbers/symbols",
                "keywords": ["password", "login", "forgot", "reset", "account access", "sign in"]
            },
            "shipping": {
                "response": "ğŸ“¦ **Shipping Information**\nâ€¢ Standard: 3-5 business days ($5.99)\nâ€¢ Express: 1-2 business days ($12.99)\nâ€¢ Overnight: Next business day ($24.99)\nâ€¢ Free shipping on orders over $50\n\nğŸŒ International shipping available to 50+ countries\nğŸ“ Same-day delivery in select cities",
                "keywords": ["shipping", "delivery", "how long", "when will", "arrival", "fast"]
            },
            "payment": {
                "response": "ğŸ’³ **Payment Methods**\nWe accept:\nâ€¢ Credit/Debit cards (Visa, MC, Amex)\nâ€¢ PayPal\nâ€¢ Apple Pay\nâ€¢ Google Pay\nâ€¢ Buy now, pay later options\n\nğŸ”’ All payments are encrypted and secure\nğŸ’° No hidden fees or charges",
                "keywords": ["payment", "credit card", "paypal", "pay", "billing", "charge"]
            },
            "cancel": {
                "response": "âŒ **Cancel Order**\nYou can cancel your order if it hasn't shipped yet.\n\nâš¡ Quick cancel:\nâ€¢ Log into your account\nâ€¢ Go to 'My Orders'\nâ€¢ Click 'Cancel' next to your order\n\nâ° Orders ship within 24 hours, so cancel ASAP!\nNeed help? Contact us immediately.",
                "keywords": ["cancel", "stop order", "don't want", "change mind"]
            }
        }

        self.TICKET_TRIGGERS = {
            "delivery_issue": {
                "keywords": ["late", "delayed", "not arrived", "slow delivery", "missing package", "lost"],
                "reason": "â±ï¸ Delivery delay/issue",
                "priority": "medium"
            },
            "product_defect": {
                "keywords": ["broken", "damaged", "defective", "not working", "faulty", "poor quality"],
                "reason": "âš ï¸ Defective product",
                "priority": "high"
            },
            "missing_item": {
                "keywords": ["missing", "not included", "incomplete order", "only received part"],
                "reason": "âŒ Missing item from order",
                "priority": "high"
            },
            "wrong_item": {
                "keywords": ["wrong", "incorrect", "different", "not what I ordered", "mistake"],
                "reason": "ğŸ”„ Incorrect item received",
                "priority": "medium"
            },
            "billing_issue": {
                "keywords": ["charged", "billing", "payment", "refund not received", "double charged", "money"],
                "reason": "ğŸ’³ Billing/payment issue",
                "priority": "high"
            },
            "website_issue": {
                "keywords": ["website down", "can't login", "error", "bug", "not loading", "crashed"],
                "reason": "ğŸŒ Website/technical issue",
                "priority": "medium"
            }
        }

        # Add welcome message
        self.add_message("assistant", "ğŸ‘‹ Hi! I'm your Customer Support Assistant. I'm here to help with:\n\nğŸ›ï¸ Orders & Tracking\nğŸ”„ Returns & Refunds\nğŸ“¦ Shipping Questions\nğŸ’³ Payment Issues\nğŸ” Account Problems\n\nWhat can I help you with today?")

    def add_message(self, role: str, content: str):
        """Add a message to the conversation history"""
        message = {
            "role": role,
            "content": content,
            "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        }
        self.messages.append(message)

    def find_knowledge_match(self, query: str) -> Optional[str]:
        """Find matching response from knowledge base"""
        query_lower = query.lower()

        for category, data in self.KNOWLEDGE_BASE.items():
            if any(keyword in query_lower for keyword in data["keywords"]):
                return data["response"]
        return None

    def check_ticket_triggers(self, query: str) -> Optional[Dict]:
        """Check if query should trigger ticket creation"""
        query_lower = query.lower()

        for trigger_type, data in self.TICKET_TRIGGERS.items():
            if any(keyword in query_lower for keyword in data["keywords"]):
                return {"reason": data["reason"], "priority": data["priority"]}
        return None

    def create_support_ticket(self, query: str, reason: str, priority: str) -> str:
        """Create a new support ticket"""
        ticket_id = f"TKT{str(len(self.tickets) + 1).zfill(4)}"
        ticket = {
            "id": ticket_id,
            "query": query,
            "reason": reason,
            "priority": priority,
            "status": "Open",
            "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "needs_human_review": priority == "high"
        }

        self.tickets.append(ticket)

        priority_emoji = "ğŸ”´" if priority == "high" else "ğŸŸ¡"
        response_time = "4 hours" if priority == "high" else "24 hours"

        return f"ğŸ“¬ **Support Ticket Created**\n\n{priority_emoji} Ticket #{ticket_id}\nğŸ“‹ Issue: {reason}\nâ° Priority: {priority.title()}\n\nğŸ“ We'll contact you within {response_time}.\nğŸ“§ Updates will be sent to your email.\n\nTicket created at: {ticket['created']}"

    def generate_ai_response(self, query: str) -> str:
        """Generate contextual AI responses"""
        query_lower = query.lower()

        # Greeting responses
        if any(word in query_lower for word in ['hello', 'hi', 'hey', 'good morning', 'good afternoon']):
            return random.choice([
                "ğŸ‘‹ Hello! Great to meet you. How can I assist you today?",
                "Hi there! ğŸ˜Š I'm here to help with any questions you have.",
                "Hello! Welcome to customer support. What can I help you with?",
                "Hey! ğŸ‘‹ Ready to help you with whatever you need."
            ])

        # Thank you responses
        if any(word in query_lower for word in ['thank', 'thanks', 'appreciate']):
            return random.choice([
                "You're very welcome! ğŸ˜Š Is there anything else I can help you with?",
                "Happy to help! ğŸ‘ Feel free to ask if you have more questions.",
                "My pleasure! ğŸŒŸ Let me know if you need anything else.",
                "Glad I could help! ğŸ˜Š Any other questions for me?"
            ])

        # Complaint/frustration responses
        if any(word in query_lower for word in ['angry', 'frustrated', 'upset', 'terrible', 'awful', 'horrible']):
            return "ğŸ˜” I'm really sorry to hear about your frustrating experience. I understand how upsetting this must be, and I'm here to help make this right. Let me see what I can do to resolve this issue for you immediately. Can you tell me more about what happened?"

        # General responses
        responses = [
            "I understand your concern. Let me help you with that right away! ğŸš€",
            "Thank you for reaching out. I'm here to assist you with your question. ğŸ˜Š",
            "I'll be happy to help you resolve this. Can you provide a bit more detail about your specific situation? ğŸ¤”",
            "That's a great question! Let me guide you through the solution. ğŸ’¡",
            "I see what you're asking about. Here's what I can do to help: ğŸ‘",
            "No problem at all! I'm here to make sure you get the help you need. âœ¨",
            "Let me look into that for you right away. I want to make sure we get this sorted out! ğŸ”"
        ]

        return random.choice(responses)

    def generate_response(self, query: str) -> str:
        """Generate appropriate response based on query"""
        # 1. Check knowledge base first
        kb_response = self.find_knowledge_match(query)
        if kb_response:
            return kb_response

        # 2. Check if ticket creation is needed
        ticket_info = self.check_ticket_triggers(query)
        if ticket_info:
            ticket_response = self.create_support_ticket(query, ticket_info["reason"], ticket_info["priority"])
            return ticket_response

        # 3. Generate contextual AI response
        ai_response = self.generate_ai_response(query)
        return ai_response

    def chat(self, user_input: str) -> str:
        """Main chat function"""
        # Add user message
        self.add_message("user", user_input)

        # Generate response
        response = self.generate_response(user_input)

        # Add assistant response
        self.add_message("assistant", response)

        return response

    def show_tickets(self):
        """Display all support tickets"""
        if not self.tickets:
            print("ğŸ“‹ No support tickets created yet.\n")
            return

        print("ğŸ« === SUPPORT TICKETS ===")
        print(f"ğŸ“Š Total: {len(self.tickets)} | Open: {len([t for t in self.tickets if t['status'] == 'Open'])}")
        print("-" * 50)

        for ticket in sorted(self.tickets, key=lambda x: x['created'], reverse=True):
            priority_emoji = "ğŸ”´" if ticket['priority'] == 'high' else "ğŸŸ¡"
            status_emoji = "ğŸŸ¢" if ticket['status'] == 'Resolved' else "ğŸ”´"

            print(f"{priority_emoji} #{ticket['id']} - {ticket['reason']}")
            print(f"   Status: {status_emoji} {ticket['status']}")
            print(f"   Created: {ticket['created']}")
            print(f"   Query: {ticket['query'][:60]}...")
            print()

    def show_conversation(self):
        """Display conversation history"""
        print("ğŸ’¬ === CONVERSATION HISTORY ===")
        print("-" * 50)

        for msg in self.messages:
            role_emoji = "ğŸ¤–" if msg['role'] == 'assistant' else "ğŸ‘¤"
            role_name = "Assistant" if msg['role'] == 'assistant' else "You"

            print(f"{role_emoji} {role_name} ({msg['timestamp']}):")
            print(f"   {msg['content']}")
            print()

def run_chatbot():
    """Run the interactive chatbot"""
    bot = CustomerSupportChatbot()

    print("ğŸ¤– === CUSTOMER SUPPORT CHATBOT ===")
    print("ğŸ’¡ Commands:")
    print("   â€¢ Type your questions normally")
    print("   â€¢ 'tickets' - View support tickets")
    print("   â€¢ 'history' - View conversation history")
    print("   â€¢ 'clear' - Clear screen")
    print("   â€¢ 'quit' - Exit chatbot")
    print("=" * 50)
    print()

    # Show welcome message
    print("ğŸ¤– Assistant:")
    print(f"   {bot.messages[0]['content']}")
    print()

    while True:
        try:
            # Get user input
            user_input = input("ğŸ‘¤ You: ").strip()

            if not user_input:
                continue

            # Handle special commands
            if user_input.lower() == 'quit':
                print("\nğŸ‘‹ Thank you for using Customer Support! Have a great day!")
                break
            elif user_input.lower() == 'tickets':
                print()
                bot.show_tickets()
                continue
            elif user_input.lower() == 'history':
                print()
                bot.show_conversation()
                continue
            elif user_input.lower() == 'clear':
                print("\n" * 50)
                continue

            # Process chat message
            print("\nğŸ¤– Assistant (typing...)")
            time.sleep(1)  # Simulate thinking time

            response = bot.chat(user_input)
            print(f"   {response}")
            print()

        except KeyboardInterrupt:
            print("\n\nğŸ‘‹ Chat interrupted. Goodbye!")
            break
        except Exception as e:
            print(f"\nâŒ Error: {e}")
            print("Please try again.\n")

# Run the chatbot/


if __name__ == "__main__":
    run_chatbot()

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import json
# import random
# import time
# from datetime import datetime
# from typing import Dict, List, Optional
# import plotly.express as px
# import pandas as pd
# 
# # Set page config
# st.set_page_config(
#     page_title="Customer Support Assistant",
#     page_icon="ğŸ¤–",
#     layout="wide",
#     initial_sidebar_state="expanded"
# )
# 
# # Custom CSS for professional styling
# st.markdown("""
# <style>
#     /* Import Google Fonts */
#     @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
# 
#     /* Global Styling */
#     .main .block-container {
#         padding-top: 2rem;
#         padding-bottom: 2rem;
#         max-width: 1200px;
#     }
# 
#     /* Custom Header */
#     .header-container {
#         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
#         padding: 2rem;
#         border-radius: 15px;
#         margin-bottom: 2rem;
#         box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
#         text-align: center;
#     }
# 
#     .header-title {
#         font-family: 'Inter', sans-serif;
#         font-size: 2.5rem;
#         font-weight: 700;
#         color: white;
#         margin: 0;
#         text-shadow: 0 2px 4px rgba(0,0,0,0.3);
#     }
# 
#     .header-subtitle {
#         font-family: 'Inter', sans-serif;
#         font-size: 1.1rem;
#         color: rgba(255,255,255,0.9);
#         margin: 0.5rem 0 0 0;
#         font-weight: 400;
#     }
# 
#     /* Chat Container */
#     .chat-container {
#         background: white;
#         border-radius: 20px;
#         padding: 1.5rem;
#         box-shadow: 0 8px 32px rgba(0,0,0,0.1);
#         border: 1px solid rgba(255,255,255,0.2);
#         backdrop-filter: blur(10px);
#     }
# 
#     /* Message Styling */
#     .user-message {
#         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
#         color: white;
#         padding: 1rem 1.5rem;
#         border-radius: 20px 20px 5px 20px;
#         margin: 1rem 0;
#         margin-left: 20%;
#         box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
#         font-family: 'Inter', sans-serif;
#         animation: slideInRight 0.3s ease-out;
#     }
# 
#     .bot-message {
#         background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
#         color: white;
#         padding: 1rem 1.5rem;
#         border-radius: 20px 20px 20px 5px;
#         margin: 1rem 0;
#         margin-right: 20%;
#         box-shadow: 0 4px 15px rgba(240, 147, 251, 0.3);
#         font-family: 'Inter', sans-serif;
#         animation: slideInLeft 0.3s ease-out;
#     }
# 
#     /* Animations */
#     @keyframes slideInRight {
#         from { transform: translateX(100%); opacity: 0; }
#         to { transform: translateX(0); opacity: 1; }
#     }
# 
#     @keyframes slideInLeft {
#         from { transform: translateX(-100%); opacity: 0; }
#         to { transform: translateX(0); opacity: 1; }
#     }
# 
#     @keyframes pulse {
#         0% { transform: scale(1); }
#         50% { transform: scale(1.05); }
#         100% { transform: scale(1); }
#     }
# 
#     /* Sidebar Styling */
#     .css-1d391kg {
#         background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
#     }
# 
#     /* Stats Cards */
#     .stats-card {
#         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
#         padding: 1.5rem;
#         border-radius: 15px;
#         color: white;
#         text-align: center;
#         margin: 1rem 0;
#         box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
#         transition: transform 0.3s ease;
#     }
# 
#     .stats-card:hover {
#         transform: translateY(-5px);
#     }
# 
#     .stats-number {
#         font-size: 2.5rem;
#         font-weight: 700;
#         margin: 0;
#     }
# 
#     .stats-label {
#         font-size: 1rem;
#         opacity: 0.9;
#         margin: 0;
#     }
# 
#     /* Ticket Cards */
#     .ticket-card {
#         background: white;
#         border-left: 5px solid #667eea;
#         padding: 1rem;
#         margin: 1rem 0;
#         border-radius: 10px;
#         box-shadow: 0 4px 15px rgba(0,0,0,0.1);
#         transition: transform 0.2s ease;
#     }
# 
#     .ticket-card:hover {
#         transform: translateX(10px);
#     }
# 
#     .ticket-high {
#         border-left-color: #f5576c;
#     }
# 
#     .ticket-medium {
#         border-left-color: #ffa726;
#     }
# 
#     /* Button Styling */
#     .stButton > button {
#         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
#         color: white;
#         border: none;
#         border-radius: 25px;
#         padding: 0.5rem 2rem;
#         font-family: 'Inter', sans-serif;
#         font-weight: 600;
#         transition: all 0.3s ease;
#         box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
#     }
# 
#     .stButton > button:hover {
#         transform: translateY(-2px);
#         box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
#     }
# 
#     /* Input Styling */
#     .stTextInput > div > div > input {
#         border-radius: 25px;
#         border: 2px solid #e0e0e0;
#         padding: 1rem;
#         font-family: 'Inter', sans-serif;
#         transition: all 0.3s ease;
#     }
# 
#     .stTextInput > div > div > input:focus {
#         border-color: #667eea;
#         box-shadow: 0 0 20px rgba(102, 126, 234, 0.2);
#     }
# 
#     /* Hide Streamlit Branding */
#     #MainMenu {visibility: hidden;}
#     footer {visibility: hidden;}
#     .stDeployButton {display:none;}
# </style>
# """, unsafe_allow_html=True)
# 
# class CustomerSupportChatbot:
#     def __init__(self):
#         if 'tickets' not in st.session_state:
#             st.session_state.tickets = []
#         if 'messages' not in st.session_state:
#             st.session_state.messages = []
#         if 'session_id' not in st.session_state:
#             st.session_state.session_id = f"session_{int(time.time())}"
# 
#         # Knowledge Base
#         self.KNOWLEDGE_BASE = {
#             "track_order": {
#                 "response": "ğŸ” **Track Your Order**\nVisit example.com/track and enter your order number. You'll get real-time updates on your shipment status.\n\nğŸ“± You can also track via:\nâ€¢ Mobile app\nâ€¢ SMS updates\nâ€¢ Email notifications",
#                 "keywords": ["track", "order", "shipment", "delivery status", "where is my order", "tracking"]
#             },
#             "return": {
#                 "response": "ğŸ”„ **Return Policy**\nWe offer a 30-day return policy for unopened items.\n\nğŸ“‹ Return Process:\nâ€¢ Visit example.com/returns\nâ€¢ Print return label\n â€¢ Package securely\nâ€¢ Drop off at any carrier location\n\nğŸ’° Refunds processed within 5-7 business days",
#                 "keywords": ["return", "refund", "exchange", "send back", "money back"]
#             },
#             "contact": {
#                 "response": "ğŸ“ **Contact Support**\nâ€¢ Email: support@example.com\nâ€¢ Phone: 1-800-HELP (24/7)\nâ€¢ Live Chat: Available 9AM-9PM EST\nâ€¢ Social Media: @ExampleSupport\n\nâ° Average response times:\nâ€¢ Chat: Under 2 minutes\nâ€¢ Email: Within 4 hours\nâ€¢ Phone: Immediate",
#                 "keywords": ["contact", "phone", "email", "support", "help", "call", "speak"]
#             },
#             "password": {
#                 "response": "ğŸ” **Password Reset**\nReset your password at example.com/forgot-password\n\nğŸ”‘ Steps:\n1. Enter your email\n2. Check for reset email (check spam folder)\n3. Click reset link\n4. Create new strong password\n\nğŸ’¡ Password tips: Use 8+ characters, mix letters/numbers/symbols",
#                 "keywords": ["password", "login", "forgot", "reset", "account access", "sign in"]
#             },
#             "shipping": {
#                 "response": "ğŸ“¦ **Shipping Information**\nâ€¢ Standard: 3-5 business days ($5.99)\nâ€¢ Express: 1-2 business days ($12.99)\nâ€¢ Overnight: Next business day ($24.99)\nâ€¢ Free shipping on orders over $50\n\nğŸŒ International shipping available to 50+ countries\nğŸ“ Same-day delivery in select cities",
#                 "keywords": ["shipping", "delivery", "how long", "when will", "arrival", "fast"]
#             },
#             "payment": {
#                 "response": "ğŸ’³ **Payment Methods**\nWe accept:\nâ€¢ Credit/Debit cards (Visa, MC, Amex)\nâ€¢ PayPal\nâ€¢ Apple Pay\nâ€¢ Google Pay\nâ€¢ Buy now, pay later options\n\nğŸ”’ All payments are encrypted and secure\nğŸ’° No hidden fees or charges",
#                 "keywords": ["payment", "credit card", "paypal", "pay", "billing", "charge"]
#             },
#             "cancel": {
#                 "response": "âŒ **Cancel Order**\nYou can cancel your order if it hasn't shipped yet.\n\nâš¡ Quick cancel:\nâ€¢ Log into your account\nâ€¢ Go to 'My Orders'\nâ€¢ Click 'Cancel' next to your order\n\nâ° Orders ship within 24 hours, so cancel ASAP!\nNeed help? Contact us immediately.",
#                 "keywords": ["cancel", "stop order", "don't want", "change mind"]
#             }
#         }
# 
#         self.TICKET_TRIGGERS = {
#             "delivery_issue": {
#                 "keywords": ["late", "delayed", "not arrived", "slow delivery", "missing package", "lost"],
#                 "reason": "â±ï¸ Delivery delay/issue",
#                 "priority": "medium"
#             },
#             "product_defect": {
#                 "keywords": ["broken", "damaged", "defective", "not working", "faulty", "poor quality"],
#                 "reason": "âš ï¸ Defective product",
#                 "priority": "high"
#             },
#             "missing_item": {
#                 "keywords": ["missing", "not included", "incomplete order", "only received part"],
#                 "reason": "âŒ Missing item from order",
#                 "priority": "high"
#             },
#             "wrong_item": {
#                 "keywords": ["wrong", "incorrect", "different", "not what I ordered", "mistake"],
#                 "reason": "ğŸ”„ Incorrect item received",
#                 "priority": "medium"
#             },
#             "billing_issue": {
#                 "keywords": ["charged", "billing", "payment", "refund not received", "double charged", "money"],
#                 "reason": "ğŸ’³ Billing/payment issue",
#                 "priority": "high"
#             },
#             "website_issue": {
#                 "keywords": ["website down", "can't login", "error", "bug", "not loading", "crashed"],
#                 "reason": "ğŸŒ Website/technical issue",
#                 "priority": "medium"
#             }
#         }
# 
#         # Initialize with welcome message if empty
#         if not st.session_state.messages:
#             welcome_msg = "ğŸ‘‹ Hi! I'm your Customer Support Assistant. I'm here to help with:\n\nğŸ›ï¸ Orders & Tracking\nğŸ”„ Returns & Refunds\nğŸ“¦ Shipping Questions\nğŸ’³ Payment Issues\nğŸ” Account Problems\n\nWhat can I help you with today?"
#             st.session_state.messages.append({
#                 "role": "assistant",
#                 "content": welcome_msg,
#                 "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
#             })
# 
#     def find_knowledge_match(self, query: str) -> Optional[str]:
#         """Find matching response from knowledge base"""
#         query_lower = query.lower()
#         for category, data in self.KNOWLEDGE_BASE.items():
#             if any(keyword in query_lower for keyword in data["keywords"]):
#                 return data["response"]
#         return None
# 
#     def check_ticket_triggers(self, query: str) -> Optional[Dict]:
#         """Check if query should trigger ticket creation"""
#         query_lower = query.lower()
#         for trigger_type, data in self.TICKET_TRIGGERS.items():
#             if any(keyword in query_lower for keyword in data["keywords"]):
#                 return {"reason": data["reason"], "priority": data["priority"]}
#         return None
# 
#     def create_support_ticket(self, query: str, reason: str, priority: str) -> str:
#         """Create a new support ticket"""
#         ticket_id = f"TKT{str(len(st.session_state.tickets) + 1).zfill(4)}"
#         ticket = {
#             "id": ticket_id,
#             "query": query,
#             "reason": reason,
#             "priority": priority,
#             "status": "Open",
#             "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
#             "needs_human_review": priority == "high"
#         }
# 
#         st.session_state.tickets.append(ticket)
# 
#         priority_emoji = "ğŸ”´" if priority == "high" else "ğŸŸ¡"
#         response_time = "4 hours" if priority == "high" else "24 hours"
# 
#         return f"ğŸ“¬ **Support Ticket Created**\n\n{priority_emoji} Ticket #{ticket_id}\nğŸ“‹ Issue: {reason}\nâ° Priority: {priority.title()}\n\nğŸ“ We'll contact you within {response_time}.\nğŸ“§ Updates will be sent to your email.\n\nTicket created at: {ticket['created']}"
# 
#     def generate_ai_response(self, query: str) -> str:
#         """Generate contextual AI responses"""
#         query_lower = query.lower()
# 
#         # Greeting responses
#         if any(word in query_lower for word in ['hello', 'hi', 'hey', 'good morning', 'good afternoon']):
#             return random.choice([
#                 "ğŸ‘‹ Hello! Great to meet you. How can I assist you today?",
#                 "Hi there! ğŸ˜Š I'm here to help with any questions you have.",
#                 "Hello! Welcome to customer support. What can I help you with?",
#                 "Hey! ğŸ‘‹ Ready to help you with whatever you need."
#             ])
# 
#         # Thank you responses
#         if any(word in query_lower for word in ['thank', 'thanks', 'appreciate']):
#             return random.choice([
#                 "You're very welcome! ğŸ˜Š Is there anything else I can help you with?",
#                 "Happy to help! ğŸ‘ Feel free to ask if you have more questions.",
#                 "My pleasure! ğŸŒŸ Let me know if you need anything else.",
#                 "Glad I could help! ğŸ˜Š Any other questions for me?"
#             ])
# 
#         # Complaint/frustration responses
#         if any(word in query_lower for word in ['angry', 'frustrated', 'upset', 'terrible', 'awful', 'horrible']):
#             return "ğŸ˜” I'm really sorry to hear about your frustrating experience. I understand how upsetting this must be, and I'm here to help make this right. Let me see what I can do to resolve this issue for you immediately. Can you tell me more about what happened?"
# 
#         # General responses
#         responses = [
#             "I understand your concern. Let me help you with that right away! ğŸš€",
#             "Thank you for reaching out. I'm here to assist you with your question. ğŸ˜Š",
#             "I'll be happy to help you resolve this. Can you provide a bit more detail about your specific situation? ğŸ¤”",
#             "That's a great question! Let me guide you through the solution. ğŸ’¡",
#             "I see what you're asking about. Here's what I can do to help: ğŸ‘",
#             "No problem at all! I'm here to make sure you get the help you need. âœ¨",
#             "Let me look into that for you right away. I want to make sure we get this sorted out! ğŸ”"
#         ]
# 
#         return random.choice(responses)
# 
#     def generate_response(self, query: str) -> str:
#         """Generate appropriate response based on query"""
#         # 1. Check knowledge base first
#         kb_response = self.find_knowledge_match(query)
#         if kb_response:
#             return kb_response
# 
#         # 2. Check if ticket creation is needed
#         ticket_info = self.check_ticket_triggers(query)
#         if ticket_info:
#             ticket_response = self.create_support_ticket(query, ticket_info["reason"], ticket_info["priority"])
#             return ticket_response
# 
#         # 3. Generate contextual AI response
#         ai_response = self.generate_ai_response(query)
#         return ai_response
# 
#     def chat(self, user_input: str) -> str:
#         """Main chat function"""
#         # Add user message
#         st.session_state.messages.append({
#             "role": "user",
#             "content": user_input,
#             "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
#         })
# 
#         # Generate response
#         response = self.generate_response(user_input)
# 
#         # Add assistant response
#         st.session_state.messages.append({
#             "role": "assistant",
#             "content": response,
#             "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
#         })
# 
#         return response
# 
# def main():
#     # Header
#     st.markdown("""
#     <div class="header-container">
#         <h1 class="header-title">ğŸ¤– Customer Support Assistant</h1>
#         <p class="header-subtitle">AI-Powered Support â€¢ 24/7 Available â€¢ Instant Responses</p>
#     </div>
#     """, unsafe_allow_html=True)
# 
#     # Initialize chatbot
#     bot = CustomerSupportChatbot()
# 
#     # Sidebar
#     with st.sidebar:
#         st.markdown("### ğŸ“Š Dashboard")
# 
#         # Stats
#         total_messages = len(st.session_state.messages)
#         total_tickets = len(st.session_state.tickets)
#         high_priority = len([t for t in st.session_state.tickets if t['priority'] == 'high'])
# 
#         col1, col2 = st.columns(2)
#         with col1:
#             st.markdown(f"""
#             <div class="stats-card">
#                 <p class="stats-number">{total_messages}</p>
#                 <p class="stats-label">Messages</p>
#             </div>
#             """, unsafe_allow_html=True)
# 
#         with col2:
#             st.markdown(f"""
#             <div class="stats-card">
#                 <p class="stats-number">{total_tickets}</p>
#                 <p class="stats-label">Tickets</p>
#             </div>
#             """, unsafe_allow_html=True)
# 
#         # Quick Actions
#         st.markdown("### âš¡ Quick Actions")
# 
#         if st.button("ğŸ« View All Tickets"):
#             st.session_state.show_tickets = True
# 
#         if st.button("ğŸ“ˆ Analytics"):
#             st.session_state.show_analytics = True
# 
#         if st.button("ğŸ—‘ï¸ Clear Chat"):
#             st.session_state.messages = [st.session_state.messages[0]]  # Keep welcome message
#             st.rerun()
# 
#         # Recent Tickets
#         if st.session_state.tickets:
#             st.markdown("### ğŸ« Recent Tickets")
#             for ticket in st.session_state.tickets[-3:]:
#                 priority_class = "ticket-high" if ticket['priority'] == 'high' else "ticket-medium"
#                 st.markdown(f"""
#                 <div class="ticket-card {priority_class}">
#                     <strong>#{ticket['id']}</strong><br>
#                     {ticket['reason']}<br>
#                     <small>{ticket['created']}</small>
#                 </div>
#                 """, unsafe_allow_html=True)
# 
#     # Main chat area
#     col1, col2 = st.columns([3, 1])
# 
#     with col1:
#         st.markdown('<div class="chat-container">', unsafe_allow_html=True)
# 
#         # Chat messages
#         chat_container = st.container()
#         with chat_container:
#             for message in st.session_state.messages:
#                 if message["role"] == "user":
#                     st.markdown(f"""
#                     <div class="user-message">
#                         <strong>You:</strong><br>{message["content"]}<br>
#                         <small style="opacity: 0.8;">{message["timestamp"]}</small>
#                     </div>
#                     """, unsafe_allow_html=True)
#                 else:
#                     st.markdown(f"""
#                     <div class="bot-message">
#                         <strong>ğŸ¤– Assistant:</strong><br>{message["content"]}<br>
#                         <small style="opacity: 0.8;">{message["timestamp"]}</small>
#                     </div>
#                     """, unsafe_allow_html=True)
# 
#         st.markdown('</div>', unsafe_allow_html=True)
# 
#         # Chat input
#         st.markdown("### ğŸ’¬ Type your message")
#         user_input = st.text_input("", placeholder="Ask me anything about your order, returns, shipping, etc.", key="chat_input")
# 
#         col_send, col_clear = st.columns([1, 4])
#         with col_send:
#             send_button = st.button("Send ğŸ“¤", use_container_width=True)
# 
#         if send_button and user_input:
#             with st.spinner("ğŸ¤– Thinking..."):
#                 time.sleep(0.5)  # Simulate processing time
#                 bot.chat(user_input)
#             st.rerun()
# 
#     with col2:
#         st.markdown("### ğŸ› ï¸ Features")
#         features = [
#             "ğŸ” Order Tracking",
#             "ğŸ”„ Returns & Refunds",
#             "ğŸ“¦ Shipping Info",
#             "ğŸ’³ Payment Help",
#             "ğŸ” Account Issues",
#             "ğŸ« Ticket Creation",
#             "ğŸ“Š Real-time Analytics"
#         ]
# 
#         for feature in features:
#             st.markdown(f"âœ… {feature}")
# 
#     # Tickets page
#     if hasattr(st.session_state, 'show_tickets') and st.session_state.show_tickets:
#         st.markdown("---")
#         st.markdown("## ğŸ« Support Tickets")
# 
#         if st.session_state.tickets:
#             for ticket in reversed(st.session_state.tickets):
#                 priority_color = "ğŸ”´" if ticket['priority'] == 'high' else "ğŸŸ¡"
#                 status_color = "ğŸŸ¢" if ticket['status'] == 'Resolved' else "ğŸ”´"
# 
#                 with st.expander(f"{priority_color} #{ticket['id']} - {ticket['reason']}"):
#                     st.write(f"**Status:** {status_color} {ticket['status']}")
#                     st.write(f"**Priority:** {ticket['priority'].title()}")
#                     st.write(f"**Created:** {ticket['created']}")
#                     st.write(f"**Query:** {ticket['query']}")
#                     st.write(f"**Needs Human Review:** {'Yes' if ticket['needs_human_review'] else 'No'}")
#         else:
#             st.info("No support tickets created yet.")
# 
#         if st.button("â† Back to Chat"):
#             st.session_state.show_tickets = False
#             st.rerun()
# 
#     # Analytics page
#     if hasattr(st.session_state, 'show_analytics') and st.session_state.show_analytics:
#         st.markdown("---")
#         st.markdown("## ğŸ“ˆ Analytics Dashboard")
# 
#         if st.session_state.messages and st.session_state.tickets:
#             # Create charts
#             col1, col2 = st.columns(2)
# 
#             with col1:
#                 # Messages over time
#                 df_messages = pd.DataFrame(st.session_state.messages)
#                 df_messages['hour'] = pd.to_datetime(df_messages['timestamp']).dt.hour
#                 msg_by_hour = df_messages.groupby('hour').size().reset_index(name='count')
# 
#                 fig1 = px.line(msg_by_hour, x='hour', y='count',
#                               title='Messages by Hour',
#                               color_discrete_sequence=['#667eea'])
#                 st.plotly_chart(fig1, use_container_width=True)
# 
#             with col2:
#                 # Tickets by priority
#                 df_tickets = pd.DataFrame(st.session_state.tickets)
#                 ticket_priority = df_tickets['priority'].value_counts().reset_index()
# 
#                 fig2 = px.pie(ticket_priority, values='count', names='priority',
#                              title='Tickets by Priority',
#                              color_discrete_sequence=['#f5576c', '#ffa726'])
#                 st.plotly_chart(fig2, use_container_width=True)
#         else:
#             st.info("Not enough data for analytics yet. Start chatting to see insights!")
# 
#         if st.button("â† Back to Chat"):
#             st.session_state.show_analytics = False
#             st.rerun()
# 
# if __name__ == "__main__":
#     main()
# import random
# import time
# from datetime import datetime
# from typing import Dict, List, Optional
# import plotly.express as px
# import pandas as pd
# 
# # Set page config
# st.set_page_config(
#     page_title="Customer Support Assistant",
#     page_icon="ğŸ¤–",
#     layout="wide",
#     initial_sidebar_state="expanded"
# )
# 
# # Custom CSS for professional styling
# st.markdown("""
# <style>
#     /* Import Google Fonts */
#     @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
# 
#     /* Global Styling */
#     .main .block-container {
#         padding-top: 2rem;
#         padding-bottom: 2rem;
#         max-width: 1200px;
#     }
# 
#     /* Custom Header */
#     .header-container {
#         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
#         padding: 2rem;
#         border-radius: 15px;
#         margin-bottom: 2rem;
#         box-shadow: 0 10px 30px rgba(102, 126, 234, 0.3);
#         text-align: center;
#     }
# 
#     .header-title {
#         font-family: 'Inter', sans-serif;
#         font-size: 2.5rem;
#         font-weight: 700;
#         color: white;
#         margin: 0;
#         text-shadow: 0 2px 4px rgba(0,0,0,0.3);
#     }
# 
#     .header-subtitle {
#         font-family: 'Inter', sans-serif;
#         font-size: 1.1rem;
#         color: rgba(255,255,255,0.9);
#         margin: 0.5rem 0 0 0;
#         font-weight: 400;
#     }
# 
#     /* Chat Container */
#     .chat-container {
#         background: white;
#         border-radius: 20px;
#         padding: 1.5rem;
#         box-shadow: 0 8px 32px rgba(0,0,0,0.1);
#         border: 1px solid rgba(255,255,255,0.2);
#         backdrop-filter: blur(10px);
#     }
# 
#     /* Message Styling */
#     .user-message {
#         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
#         color: white;
#         padding: 1rem 1.5rem;
#         border-radius: 20px 20px 5px 20px;
#         margin: 1rem 0;
#         margin-left: 20%;
#         box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
#         font-family: 'Inter', sans-serif;
#         animation: slideInRight 0.3s ease-out;
#     }
# 
#     .bot-message {
#         background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
#         color: white;
#         padding: 1rem 1.5rem;
#         border-radius: 20px 20px 20px 5px;
#         margin: 1rem 0;
#         margin-right: 20%;
#         box-shadow: 0 4px 15px rgba(240, 147, 251, 0.3);
#         font-family: 'Inter', sans-serif;
#         animation: slideInLeft 0.3s ease-out;
#     }
# 
#     /* Animations */
#     @keyframes slideInRight {
#         from { transform: translateX(100%); opacity: 0; }
#         to { transform: translateX(0); opacity: 1; }
#     }
# 
#     @keyframes slideInLeft {
#         from { transform: translateX(-100%); opacity: 0; }
#         to { transform: translateX(0); opacity: 1; }
#     }
# 
#     @keyframes pulse {
#         0% { transform: scale(1); }
#         50% { transform: scale(1.05); }
#         100% { transform: scale(1); }
#     }
# 
#     /* Sidebar Styling */
#     .css-1d391kg {
#         background: linear-gradient(180deg, #667eea 0%, #764ba2 100%);
#     }
# 
#     /* Stats Cards */
#     .stats-card {
#         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
#         padding: 1.5rem;
#         border-radius: 15px;
#         color: white;
#         text-align: center;
#         margin: 1rem 0;
#         box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
#         transition: transform 0.3s ease;
#     }
# 
#     .stats-card:hover {
#         transform: translateY(-5px);
#     }
# 
#     .stats-number {
#         font-size: 2.5rem;
#         font-weight: 700;
#         margin: 0;
#     }
# 
#     .stats-label {
#         font-size: 1rem;
#         opacity: 0.9;
#         margin: 0;
#     }
# 
#     /* Ticket Cards */
#     .ticket-card {
#         background: white;
#         border-left: 5px solid #667eea;
#         padding: 1rem;
#         margin: 1rem 0;
#         border-radius: 10px;
#         box-shadow: 0 4px 15px rgba(0,0,0,0.1);
#         transition: transform 0.2s ease;
#     }
# 
#     .ticket-card:hover {
#         transform: translateX(10px);
#     }
# 
#     .ticket-high {
#         border-left-color: #f5576c;
#     }
# 
#     .ticket-medium {
#         border-left-color: #ffa726;
#     }
# 
#     /* Button Styling */
#     .stButton > button {
#         background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
#         color: white;
#         border: none;
#         border-radius: 25px;
#         padding: 0.5rem 2rem;
#         font-family: 'Inter', sans-serif;
#         font-weight: 600;
#         transition: all 0.3s ease;
#         box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
#     }
# 
#     .stButton > button:hover {
#         transform: translateY(-2px);
#         box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
#     }
# 
#     /* Input Styling */
#     .stTextInput > div > div > input {
#         border-radius: 25px;
#         border: 2px solid #e0e0e0;
#         padding: 1rem;
#         font-family: 'Inter', sans-serif;
#         transition: all 0.3s ease;
#     }
# 
#     .stTextInput > div > div > input:focus {
#         border-color: #667eea;
#         box-shadow: 0 0 20px rgba(102, 126, 234, 0.2);
#     }
# 
#     /* Hide Streamlit Branding */
#     #MainMenu {visibility: hidden;}
#     footer {visibility: hidden;}
#     .stDeployButton {display:none;}
# </style>
# """, unsafe_allow_html=True)
# 
# class CustomerSupportChatbot:
#     def __init__(self):
#         if 'tickets' not in st.session_state:
#             st.session_state.tickets = []
#         if 'messages' not in st.session_state:
#             st.session_state.messages = []
#         if 'session_id' not in st.session_state:
#             st.session_state.session_id = f"session_{int(time.time())}"
# 
#         # Knowledge Base
#         self.KNOWLEDGE_BASE = {
#             "track_order": {
#                 "response": "ğŸ” **Track Your Order**\nVisit example.com/track and enter your order number. You'll get real-time updates on your shipment status.\n\nğŸ“± You can also track via:\nâ€¢ Mobile app\nâ€¢ SMS updates\nâ€¢ Email notifications",
#                 "keywords": ["track", "order", "shipment", "delivery status", "where is my order", "tracking"]
#             },
#             "return": {
#                 "response": "ğŸ”„ **Return Policy**\nWe offer a 30-day return policy for unopened items.\n\nğŸ“‹ Return Process:\nâ€¢ Visit example.com/returns\nâ€¢ Print return label\n â€¢ Package securely\nâ€¢ Drop off at any carrier location\n\nğŸ’° Refunds processed within 5-7 business days",
#                 "keywords": ["return", "refund", "exchange", "send back", "money back"]
#             },
#             "contact": {
#                 "response": "ğŸ“ **Contact Support**\nâ€¢ Email: support@example.com\nâ€¢ Phone: 1-800-HELP (24/7)\nâ€¢ Live Chat: Available 9AM-9PM EST\nâ€¢ Social Media: @ExampleSupport\n\nâ° Average response times:\nâ€¢ Chat: Under 2 minutes\nâ€¢ Email: Within 4 hours\nâ€¢ Phone: Immediate",
#                 "keywords": ["contact", "phone", "email", "support", "help", "call", "speak"]
#             },
#             "password": {
#                 "response": "ğŸ” **Password Reset**\nReset your password at example.com/forgot-password\n\nğŸ”‘ Steps:\n1. Enter your email\n2. Check for reset email (check spam folder)\n3. Click reset link\n4. Create new strong password\n\nğŸ’¡ Password tips: Use 8+ characters, mix letters/numbers/symbols",
#                 "keywords": ["password", "login", "forgot", "reset", "account access", "sign in"]
#             },
#             "shipping": {
#                 "response": "ğŸ“¦ **Shipping Information**\nâ€¢ Standard: 3-5 business days ($5.99)\nâ€¢ Express: 1-2 business days ($12.99)\nâ€¢ Overnight: Next business day ($24.99)\nâ€¢ Free shipping on orders over $50\n\nğŸŒ International shipping available to 50+ countries\nğŸ“ Same-day delivery in select cities",
#                 "keywords": ["shipping", "delivery", "how long", "when will", "arrival", "fast"]
#             },
#             "payment": {
#                 "response": "ğŸ’³ **Payment Methods**\nWe accept:\nâ€¢ Credit/Debit cards (Visa, MC, Amex)\nâ€¢ PayPal\nâ€¢ Apple Pay\nâ€¢ Google Pay\nâ€¢ Buy now, pay later options\n\nğŸ”’ All payments are encrypted and secure\nğŸ’° No hidden fees or charges",
#                 "keywords": ["payment", "credit card", "paypal", "pay", "billing", "charge"]
#             },
#             "cancel": {
#                 "response": "âŒ **Cancel Order**\nYou can cancel your order if it hasn't shipped yet.\n\nâš¡ Quick cancel:\nâ€¢ Log into your account\nâ€¢ Go to 'My Orders'\nâ€¢ Click 'Cancel' next to your order\n\nâ° Orders ship within 24 hours, so cancel ASAP!\nNeed help? Contact us immediately.",
#                 "keywords": ["cancel", "stop order", "don't want", "change mind"]
#             }
#         }
# 
#         self.TICKET_TRIGGERS = {
#             "delivery_issue": {
#                 "keywords": ["late", "delayed", "not arrived", "slow delivery", "missing package", "lost"],
#                 "reason": "â±ï¸ Delivery delay/issue",
#                 "priority": "medium"
#             },
#             "product_defect": {
#                 "keywords": ["broken", "damaged", "defective", "not working", "faulty", "poor quality"],
#                 "reason": "âš ï¸ Defective product",
#                 "priority": "high"
#             },
#             "missing_item": {
#                 "keywords": ["missing", "not included", "incomplete order", "only received part"],
#                 "reason": "âŒ Missing item from order",
#                 "priority": "high"
#             },
#             "wrong_item": {
#                 "keywords": ["wrong", "incorrect", "different", "not what I ordered", "mistake"],
#                 "reason": "ğŸ”„ Incorrect item received",
#                 "priority": "medium"
#             },
#             "billing_issue": {
#                 "keywords": ["charged", "billing", "payment", "refund not received", "double charged", "money"],
#                 "reason": "ğŸ’³ Billing/payment issue",
#                 "priority": "high"
#             },
#             "website_issue": {
#                 "keywords": ["website down", "can't login", "error", "bug", "not loading", "crashed"],
#                 "reason": "ğŸŒ Website/technical issue",
#                 "priority": "medium"
#             }
#         }
# 
#         # Initialize with welcome message if empty
#         if not st.session_state.messages:
#             welcome_msg = "ğŸ‘‹ Hi! I'm your Customer Support Assistant. I'm here to help with:\n\nğŸ›ï¸ Orders & Tracking\nğŸ”„ Returns & Refunds\nğŸ“¦ Shipping Questions\nğŸ’³ Payment Issues\nğŸ” Account Problems\n\nWhat can I help you with today?"
#             st.session_state.messages.append({
#                 "role": "assistant",
#                 "content": welcome_msg,
#                 "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
#             })
# 
#     def find_knowledge_match(self, query: str) -> Optional[str]:
#         """Find matching response from knowledge base"""
#         query_lower = query.lower()
#         for category, data in self.KNOWLEDGE_BASE.items():
#             if any(keyword in query_lower for keyword in data["keywords"]):
#                 return data["response"]
#         return None
# 
#     def check_ticket_triggers(self, query: str) -> Optional[Dict]:
#         """Check if query should trigger ticket creation"""
#         query_lower = query.lower()
#         for trigger_type, data in self.TICKET_TRIGGERS.items():
#             if any(keyword in query_lower for keyword in data["keywords"]):
#                 return {"reason": data["reason"], "priority": data["priority"]}
#         return None
# 
#     def create_support_ticket(self, query: str, reason: str, priority: str) -> str:
#         """Create a new support ticket"""
#         ticket_id = f"TKT{str(len(st.session_state.tickets) + 1).zfill(4)}"
#         ticket = {
#             "id": ticket_id,
#             "query": query,
#             "reason": reason,
#             "priority": priority,
#             "status": "Open",
#             "created": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
#             "needs_human_review": priority == "high"
#         }
# 
#         st.session_state.tickets.append(ticket)
# 
#         priority_emoji = "ğŸ”´" if priority == "high" else "ğŸŸ¡"
#         response_time = "4 hours" if priority == "high" else "24 hours"
# 
#         return f"ğŸ“¬ **Support Ticket Created**\n\n{priority_emoji} Ticket #{ticket_id}\nğŸ“‹ Issue: {reason}\nâ° Priority: {priority.title()}\n\nğŸ“ We'll contact you within {response_time}.\nğŸ“§ Updates will be sent to your email.\n\nTicket created at: {ticket['created']}"
# 
#     def generate_ai_response(self, query: str) -> str:
#         """Generate contextual AI responses"""
#         query_lower = query.lower()
# 
#         # Greeting responses
#         if any(word in query_lower for word in ['hello', 'hi', 'hey', 'good morning', 'good afternoon']):
#             return random.choice([
#                 "ğŸ‘‹ Hello! Great to meet you. How can I assist you today?",
#                 "Hi there! ğŸ˜Š I'm here to help with any questions you have.",
#                 "Hello! Welcome to customer support. What can I help you with?",
#                 "Hey! ğŸ‘‹ Ready to help you with whatever you need."
#             ])
# 
#         # Thank you responses
#         if any(word in query_lower for word in ['thank', 'thanks', 'appreciate']):
#             return random.choice([
#                 "You're very welcome! ğŸ˜Š Is there anything else I can help you with?",
#                 "Happy to help! ğŸ‘ Feel free to ask if you have more questions.",
#                 "My pleasure! ğŸŒŸ Let me know if you need anything else.",
#                 "Glad I could help! ğŸ˜Š Any other questions for me?"
#             ])
# 
#         # Complaint/frustration responses
#         if any(word in query_lower for word in ['angry', 'frustrated', 'upset', 'terrible', 'awful', 'horrible']):
#             return "ğŸ˜” I'm really sorry to hear about your frustrating experience. I understand how upsetting this must be, and I'm here to help make this right. Let me see what I can do to resolve this issue for you immediately. Can you tell me more about what happened?"
# 
#         # General responses
#         responses = [
#             "I understand your concern. Let me help you with that right away! ğŸš€",
#             "Thank you for reaching out. I'm here to assist you with your question. ğŸ˜Š",
#             "I'll be happy to help you resolve this. Can you provide a bit more detail about your specific situation? ğŸ¤”",
#             "That's a great question! Let me guide you through the solution. ğŸ’¡",
#             "I see what you're asking about. Here's what I can do to help: ğŸ‘",
#             "No problem at all! I'm here to make sure you get the help you need. âœ¨",
#             "Let me look into that for you right away. I want to make sure we get this sorted out! ğŸ”"
#         ]
# 
#         return random.choice(responses)
# 
#     def generate_response(self, query: str) -> str:
#         """Generate appropriate response based on query"""
#         # 1. Check knowledge base first
#         kb_response = self.find_knowledge_match(query)
#         if kb_response:
#             return kb_response
# 
#         # 2. Check if ticket creation is needed
#         ticket_info = self.check_ticket_triggers(query)
#         if ticket_info:
#             ticket_response = self.create_support_ticket(query, ticket_info["reason"], ticket_info["priority"])
#             return ticket_response
# 
#         # 3. Generate contextual AI response
#         ai_response = self.generate_ai_response(query)
#         return ai_response
# 
#     def chat(self, user_input: str) -> str:
#         """Main chat function"""
#         # Add user message
#         st.session_state.messages.append({
#             "role": "user",
#             "content": user_input,
#             "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
#         })
# 
#         # Generate response
#         response = self.generate_response(user_input)
# 
#         # Add assistant response
#         st.session_state.messages.append({
#             "role": "assistant",
#             "content": response,
#             "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
#         })
# 
#         return response
# 
# def main():
#     # Header
#     st.markdown("""
#     <div class="header-container">
#         <h1 class="header-title">ğŸ¤– Customer Support Assistant</h1>
#         <p class="header-subtitle">AI-Powered Support â€¢ 24/7 Available â€¢ Instant Responses</p>
#     </div>
#     """, unsafe_allow_html=True)
# 
#     # Initialize chatbot
#     bot = CustomerSupportChatbot()
# 
#     # Sidebar
#     with st.sidebar:
#         st.markdown("### ğŸ“Š Dashboard")
# 
#         # Stats
#         total_messages = len(st.session_state.messages)
#         total_tickets = len(st.session_state.tickets)
#         high_priority = len([t for t in st.session_state.tickets if t['priority'] == 'high'])
# 
#         col1, col2 = st.columns(2)
#         with col1:
#             st.markdown(f"""
#             <div class="stats-card">
#                 <p class="stats-number">{total_messages}</p>
#                 <p class="stats-label">Messages</p>
#             </div>
#             """, unsafe_allow_html=True)
# 
#         with col2:
#             st.markdown(f"""
#             <div class="stats-card">
#                 <p class="stats-number">{total_tickets}</p>
#                 <p class="stats-label">Tickets</p>
#             </div>
#             """, unsafe_allow_html=True)
# 
#         # Quick Actions
#         st.markdown("### âš¡ Quick Actions")
# 
#         if st.button("ğŸ« View All Tickets"):
#             st.session_state.show_tickets = True
# 
#         if st.button("ğŸ“ˆ Analytics"):
#             st.session_state.show_analytics = True
# 
#         if st.button("ğŸ—‘ï¸ Clear Chat"):
#             st.session_state.messages = [st.session_state.messages[0]]  # Keep welcome message
#             st.rerun()
# 
#         # Recent Tickets
#         if st.session_state.tickets:
#             st.markdown("### ğŸ« Recent Tickets")
#             for ticket in st.session_state.tickets[-3:]:
#                 priority_class = "ticket-high" if ticket['priority'] == 'high' else "ticket-medium"
#                 st.markdown(f"""
#                 <div class="ticket-card {priority_class}">
#                     <strong>#{ticket['id']}</strong><br>
#                     {ticket['reason']}<br>
#                     <small>{ticket['created']}</small>
#                 </div>
#                 """, unsafe_allow_html=True)
# 
#     # Main chat area
#     col1, col2 = st.columns([3, 1])
# 
#     with col1:
#         st.markdown('<div class="chat-container">', unsafe_allow_html=True)
# 
#         # Chat messages
#         chat_container = st.container()
#         with chat_container:
#             for message in st.session_state.messages:
#                 if message["role"] == "user":
#                     st.markdown(f"""
#                     <div class="user-message">
#                         <strong>You:</strong><br>{message["content"]}<br>
#                         <small style="opacity: 0.8;">{message["timestamp"]}</small>
#                     </div>
#                     """, unsafe_allow_html=True)
#                 else:
#                     st.markdown(f"""
#                     <div class="bot-message">
#                         <strong>ğŸ¤– Assistant:</strong><br>{message["content"]}<br>
#                         <small style="opacity: 0.8;">{message["timestamp"]}</small>
#                     </div>
#                     """, unsafe_allow_html=True)
# 
#         st.markdown('</div>', unsafe_allow_html=True)
# 
#         # Chat input
#         st.markdown("### ğŸ’¬ Type your message")
#         user_input = st.text_input("", placeholder="Ask me anything about your order, returns, shipping, etc.", key="chat_input")
# 
#         col_send, col_clear = st.columns([1, 4])
#         with col_send:
#             send_button = st.button("Send ğŸ“¤", use_container_width=True)
# 
#         if send_button and user_input:
#             with st.spinner("ğŸ¤– Thinking..."):
#                 time.sleep(0.5)  # Simulate processing time
#                 bot.chat(user_input)
#             st.rerun()
# 
#     with col2:
#         st.markdown("### ğŸ› ï¸ Features")
#         features = [
#             "ğŸ” Order Tracking",
#             "ğŸ”„ Returns & Refunds",
#             "ğŸ“¦ Shipping Info",
#             "ğŸ’³ Payment Help",
#             "ğŸ” Account Issues",
#             "ğŸ« Ticket Creation",
#             "ğŸ“Š Real-time Analytics"
#         ]
# 
#         for feature in features:
#             st.markdown(f"âœ… {feature}")
# 
#     # Tickets page
#     if hasattr(st.session_state, 'show_tickets') and st.session_state.show_tickets:
#         st.markdown("---")
#         st.markdown("## ğŸ« Support Tickets")
# 
#         if st.session_state.tickets:
#             for ticket in reversed(st.session_state.tickets):
#                 priority_color = "ğŸ”´" if ticket['priority'] == 'high' else "ğŸŸ¡"
#                 status_color = "ğŸŸ¢" if ticket['status'] == 'Resolved' else "ğŸ”´"
# 
#                 with st.expander(f"{priority_color} #{ticket['id']} - {ticket['reason']}"):
#                     st.write(f"**Status:** {status_color} {ticket['status']}")
#                     st.write(f"**Priority:** {ticket['priority'].title()}")
#                     st.write(f"**Created:** {ticket['created']}")
#                     st.write(f"**Query:** {ticket['query']}")
#                     st.write(f"**Needs Human Review:** {'Yes' if ticket['needs_human_review'] else 'No'}")
#         else:
#             st.info("No support tickets created yet.")
# 
#         if st.button("â† Back to Chat"):
#             st.session_state.show_tickets = False
#             st.rerun()
# 
#     # Analytics page
#     if hasattr(st.session_state, 'show_analytics') and st.session_state.show_analytics:
#         st.markdown("---")
#         st.markdown("## ğŸ“ˆ Analytics Dashboard")
# 
#         if st.session_state.messages and st.session_state.tickets:
#             # Create charts
#             col1, col2 = st.columns(2)
# 
#             with col1:
#                 # Messages over time
#                 df_messages = pd.DataFrame(st.session_state.messages)
#                 df_messages['hour'] = pd.to_datetime(df_messages['timestamp']).dt.hour
#                 msg_by_hour = df_messages.groupby('hour').size().reset_index(name='count')
# 
#                 fig1 = px.line(msg_by_hour, x='hour', y='count',
#                               title='Messages by Hour',
#                               color_discrete_sequence=['#667eea'])
#                 st.plotly_chart(fig1, use_container_width=True)
# 
#             with col2:
#                 # Tickets by priority
#                 df_tickets = pd.DataFrame(st.session_state.tickets)
#                 ticket_priority = df_tickets['priority'].value_counts().reset_index()
# 
#                 fig2 = px.pie(ticket_priority, values='count', names='priority',
#                              title='Tickets by Priority',
#                              color_discrete_sequence=['#f5576c', '#ffa726'])
#                 st.plotly_chart(fig2, use_container_width=True)
#         else:
#             st.info("Not enough data for analytics yet. Start chatting to see insights!")
# 
#         if st.button("â† Back to Chat"):
#             st.session_state.show_analytics = False
#             st.rerun()
# 
# if __name__ == "__main__":
#     main()

pip install streamlit

# Start Streamlit in background
!streamlit run app.py --server.port 8501 &>/dev/null &

# Create public tunnel (no password)
!npx localtunnel --port 8501 --subdomain myaichatbot & sleep 5

!curl https://loca.lt/mytunnelpassword

!pip install flask-ngrok flask flask-cors transformers torch



from flask import Flask, request, jsonify
from flask_cors import CORS
from flask_ngrok import run_with_ngrok
from transformers import pipeline

# Load models
summary_pipeline = pipeline("summarization")
qa_pipeline = pipeline("question-answering")

articles = {
    "reset password": "To reset your password, go to settings > security and click on 'Reset Password'.",
    "account locked": "Accounts may be locked due to suspicious activity. Verify identity to unlock.",
    "payment failure": "If payment fails, verify card details or try a different payment method."
}

app = Flask(__name__)
run_with_ngrok(app)  # This replaces app.run()
CORS(app)

def search_articles(query):
    for keyword, content in articles.items():
        if keyword in query.lower():
            return content
    return "No relevant article found."

@app.route("/agent-assist", methods=["POST"])
def agent_assist():
    data = request.get_json()
    ticket_text = data.get("ticket", "")

    if not ticket_text.strip():
        return jsonify({"error": "Empty ticket received."}), 400

    try:
        summary = summary_pipeline(ticket_text, max_length=60, min_length=20, do_sample=False)[0]['summary_text']
    except:
        summary = "Could not summarize the ticket."

    suggested_article = search_articles(ticket_text)
    response_draft = f"Hi! Based on the issue described, here's something that might help: {suggested_article}"

    return jsonify({
        "summary": summary,
        "suggested_article": suggested_article,
        "draft_response": response_draft
    })

app.run()



!pip install flask flask-cors transformers torch pyngrok --quiet

from pyngrok import conf
conf.get_default().auth_token = "2xbFEEwOudtzz7bH3035AqoVE5d_7gC4fvBSAKoY9MVofKCBH"

!pip install flask flask-ngrok transformers

from flask import Flask, request, jsonify
from flask_ngrok import run_with_ngrok
from transformers import pipeline

summarizer = pipeline("summarization")
qa_pipeline = pipeline("question-answering")

app = Flask(__name__)
run_with_ngrok(app)  # Automatically runs ngrok on app.run()

@app.route('/')
def home():
    return "Agent Assistant Chatbot is running."

@app.route("/summarize", methods=["POST"])
def summarize():
    data = request.json
    text = data.get("text", "")
    summary = summarizer(text, max_length=130, min_length=30, do_sample=False)
    return jsonify({"summary": summary[0]["summary_text"]})

@app.route("/ask", methods=["POST"])
def ask():
    data = request.json
    context = data.get("context", "")
    question = data.get("question", "")
    answer = qa_pipeline(question=question, context=context)
    return jsonify({"answer": answer["answer"]})

app.run()





"""Agent Support Chatbot â€“ minimal working prototype
---------------------------------------------------
This file contains a *selfâ€‘contained* version of the chatbot youâ€™re building.
It bootstraps a few sample tickets and articles so you can run it immediately
and iterate.  Fill in or swap out the sample data / helper logic as you grow.
"""
from __future__ import annotations
import datetime as dt
from typing import Dict, List


class AgentSupportChatbot:  # ==========================
    """CLIâ€‘style assistant for customerâ€‘support agents"""

    # ---------- CONSTRUCTOR & STATE ----------
    def __init__(self,
                 tickets: List[Dict] | None = None,
                 knowledge_articles: List[Dict] | None = None):
        # ğŸ—‚  Ticket & KB storage (replace with DB, API, etc.)
        self.tickets: List[Dict] = tickets if tickets is not None else self._seed_tickets()
        self.knowledge_articles: List[Dict] = (
            knowledge_articles if knowledge_articles is not None else self._seed_articles()
        )

    # ---------- SEED DATA (for demo / testing) ----------
    @staticmethod
    def _seed_tickets() -> List[Dict]:
        now = dt.datetime.now()
        return [
            {
                "id": "TKT0001",
                "status": "open",
                "priority": "high",
                "category": "delivery_issue",
                "customer_sentiment": "frustrated",
                "created": now - dt.timedelta(hours=1),
                "customer_message": "My order hasn't arrived yet and it's already 3 days late!",
            },
            {
                "id": "TKT0002",
                "status": "open",
                "priority": "medium",
                "category": "billing_issue",
                "customer_sentiment": "neutral",
                "created": now - dt.timedelta(hours=5),
                "customer_message": "I think I was charged twice for the same item.",
            },
            {
                "id": "TKT0003",
                "status": "closed",
                "priority": "low",
                "category": "product_defect",
                "customer_sentiment": "angry",
                "created": now - dt.timedelta(days=1, hours=2),
                "customer_message": "The keyboard keys are all sticking after one week of use.",
            },
        ]

    @staticmethod
    def _seed_articles() -> List[Dict]:
        return [
            {
                "id": "ART001",
                "title": "How to Track and Expedite a Delivery",
                "content": "Steps agents should follow when a delivery is delayed...",
                "tags": ["delivery", "tracking", "shipping"],
            },
            {
                "id": "ART002",
                "title": "Processing Refunds for Duplicate Charges",
                "content": "Guide on identifying and refunding duplicate transactions...",
                "tags": ["billing", "refund", "duplicate"],
            },
        ]

    # ---------- RESPONSE TEMPLATES ----------
    def get_solution_template(self, ticket: Dict) -> str:
        """Generate solution template based on ticket category"""
        category = ticket["category"]
        solutions = {
            "delivery_issue": (
                "I've checked your order status and will immediately contact our shipping partner "
                "to expedite your delivery. You should receive an update within 2 hours, and I'll "
                "personally monitor this until resolved."
            ),
            "product_defect": (
                "I've arranged for an immediate replacement to be shipped to you via express "
                "delivery at no charge. You'll receive a prepaid return label for the defective "
                "item, and the replacement should arrive within 1â€‘2 business days."
            ),
            "billing_issue": (
                "I've reviewed your account and can see the duplicate charge. I'm processing the "
                "refund right now, and you should see the credit back to your account within 2â€‘3 "
                "business days. I'll send you a confirmation email shortly."
            ),
            "account_issue": (
                "I'll help you regain access to your account right away. I'm sending you a secure "
                "password reset link, and I'll also enable additional security features to protect "
                "your account going forward."
            ),
        }
        return solutions.get(category, (
            "Let me investigate this issue thoroughly and provide you with a complete solution "
            "within the next hour."
        ))

    def get_followup_template(self, ticket: Dict) -> str:
        return (
            "I'll follow up with you personally to ensure everything is resolved to your "
            "satisfaction. If you have any questions or concerns in the meantime, please "
            "don't hesitate to reach out directly."
        )

    # ---------- QUICK UTILITY METHODS ----------
    def get_suggested_actions(self, ticket: Dict) -> List[str]:
        """Very simple ruleâ€‘based suggestions; replace with ML or rules engine"""
        base = ["Respond to customer", "Log internal note"]
        if ticket["priority"] == "high":
            base.append("Escalate to Tierâ€‘2 support")
        if ticket["category"] == "billing_issue":
            base.append("Process refund via Stripe dashboard")
        return base

    def get_resolution_time(self, ticket: Dict) -> str:
        """Crude ETA based on priority"""
        return {
            "high": "2 h",
            "medium": "6 h",
            "low": "1 d",
        }.get(ticket["priority"], "6 h")

    # ---------- TICKET SUMMARISER ----------
    def summarize_ticket(self, ticket_id: str) -> str:
        ticket = next((t for t in self.tickets if t["id"] == ticket_id), None)
        if not ticket:
            return "Ticket not found"
        summary = f"""
ğŸ“‹ TICKET SUMMARY: {ticket['id']}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ”´ Priority: {ticket['priority'].upper()}
ğŸ“‚ Category: {ticket['category'].replace('_', ' ').title()}
ğŸ˜Ÿ Customer Sentiment: {ticket['customer_sentiment'].title()}
ğŸ“… Created: {ticket['created'].strftime('%Yâ€‘%mâ€‘%d %H:%M')}

ğŸ“ Issue: {ticket['customer_message']}

âš¡ RECOMMENDED ACTIONS:
{chr(10).join('â€¢ '+a for a in self.get_suggested_actions(ticket))}

â± Est. Resolution: {self.get_resolution_time(ticket)}
ğŸ¯ Escalation: {'YES' if ticket['priority']=='high' else 'NO'}
        """.strip()
        return summary

    # ---------- KNOWLEDGE SEARCH ----------
    def search_knowledge(self, query: str) -> List[Dict]:
        query_lower = query.lower()
        q_tokens = set(query_lower.split())
        results: List[Dict] = []
        for art in self.knowledge_articles:
            score = 0
            if query_lower in art["title"].lower():
                score += 3
            if query_lower in art["content"].lower():
                score += 2
            if q_tokens & set(art["tags"]):
                score += 1
            if score:
                results.append({**art, "relevance_score": score})
        return sorted(results, key=lambda x: x["relevance_score"], reverse=True)

    # ---------- DASHBOARD ----------
    def get_agent_dashboard(self) -> str:
        open_tickets = [t for t in self.tickets if t["status"] == "open"]
        high_priority = [t for t in open_tickets if t["priority"] == "high"]
        avg_resp = "N/A"
        if open_tickets:
            now = dt.datetime.now()
            avg_secs = sum((now - t["created"]).total_seconds() for t in open_tickets) / len(open_tickets)
            avg_resp = f"{avg_secs//60:.0f} minutes"
        dash = [
            "ğŸ¯ AGENT DASHBOARD",
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
            "ğŸ“Š Tickets Overview:",
            f"â€¢ Total Open: {len(open_tickets)}",
            f"â€¢ High Priority: {len(high_priority)}",
            f"â€¢ Avg Response Time: {avg_resp}",
            "",
            "ğŸ”¥ URGENT TICKETS:",
        ]
        for t in high_priority[:3]:
            dash.append(f"â€¢ {t['id']}: {t['customer_message'][:50]}â€¦")
        return "\n".join(dash)

    # ---------- ANALYSE & DRAFT (stub) ----------
    def analyze_ticket(self, ticket_id: str) -> Dict:
        ticket = next((t for t in self.tickets if t["id"] == ticket_id), None)
        if not ticket:
            return {"error": "Ticket not found"}
        return {
            "ticket_id": ticket_id,
            "priority_level": ticket["priority"],
            "estimated_resolution_time": self.get_resolution_time(ticket),
            "escalation_needed": ticket["priority"] == "high",
            "suggested_actions": self.get_suggested_actions(ticket),
            "relevant_articles": self.search_knowledge(ticket["category"]),
            "customer_context": {
                "approach": ticket["customer_sentiment"],
                "tone": "empathetic & proactive" if ticket["priority"] == "high" else "helpful",
            },
        }

    def draft_response(self, ticket_id: str, response_type: str = "standard") -> str:
        ticket = next((t for t in self.tickets if t["id"] == ticket_id), None)
        if not ticket:
            return "Ticket not found"
        if response_type == "apology":
            return (
                "I'm truly sorry for the inconvenience you've experienced. "
                "I understand how frustrating this must be and appreciate your patience while we resolve it."
            )
        if response_type == "solution":
            return self.get_solution_template(ticket)
        if response_type == "follow_up":
            return self.get_followup_template(ticket)
        # default: include apology + solution + followâ€‘up
        return "\n\n".join([
            self.draft_response(ticket_id, "apology"),
            self.draft_response(ticket_id, "solution"),
            self.draft_response(ticket_id, "follow_up"),
        ])

    # ---------- CHAT LOOP ----------
    def chat(self, agent_input: str) -> str:
        cmd = agent_input.strip()
        lower = cmd.lower()
        if lower.startswith("analyze "):
            tk = cmd.split(" ", 1)[1].upper()
            analysis = self.analyze_ticket(tk)
            if "error" in analysis:
                return f"âŒ {analysis['error']}"
            return f"""
ğŸ” TICKET ANALYSIS: {analysis['ticket_id']}
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âš¡ Priority: {analysis['priority_level'].upper()}
â± Est. Resolution: {analysis['estimated_resolution_time']}
ğŸš¨ Escalation Needed: {'YES' if analysis['escalation_needed'] else 'NO'}

ğŸ’¡ SUGGESTED ACTIONS:\n{chr(10).join('â€¢ '+a for a in analysis['suggested_actions'])}

ğŸ“š RELEVANT ARTICLES:\n{chr(10).join('â€¢ '+a['title']+' ('+a['id']+')' for a in analysis['relevant_articles'][:3])}

ğŸ­ CUSTOMER CONTEXT:\nâ€¢ Sentiment: {analysis['customer_context']['approach']}\nâ€¢ Recommended Tone: {analysis['customer_context']['tone']}
            """.strip()
        elif lower.startswith("draft "):
            parts = cmd.split(" ", 2)  # draft ID [type]
            if len(parts) < 2:
                return "âŒ Usage: draft [TICKET_ID] [type]"
            tk = parts[1].upper()
            rtype = parts[2] if len(parts) > 2 else "standard"
            return f"ğŸ“ DRAFT RESPONSE FOR {tk}:\n\n{self.draft_response(tk, rtype)}"
        elif lower.startswith("summarize "):
            tk = cmd.split(" ", 1)[1].upper()
            return self.summarize_ticket(tk)
        elif lower.startswith("search "):
            q = cmd.split(" ", 1)[1]
            res = self.search_knowledge(q)
            if not res:
                return f"âŒ No articles found for '{q}'"
            out = [f"ğŸ” KNOWLEDGE SEARCH RESULTS for '{q}':\n"]
            for a in res[:3]:
                out.append(f"ğŸ“„ {a['title']} ({a['id']})\n{a['content']}\n")
            return "\n".join(out)
        elif lower in {"dashboard", "dash"}:
            return self.get_agent_dashboard()
        elif lower == "help":
            return (
                "ğŸ¤– AGENT ASSISTANT COMMANDS:\n"
                "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                "â€¢ analyze [TICKET_ID] â€“ Ticket analysis & suggestions\n"
                "â€¢ draft [TICKET_ID] [type] â€“ Draft response (apology|solution|follow_up)\n"
                "â€¢ summarize [TICKET_ID] â€“ Ticket summary\n"
                "â€¢ search [query] â€“ Search knowledge base\n"
                "â€¢ dashboard â€“ View agent dashboard\n"
                "â€¢ quit â€“ Exit\n"
            )
        else:
            return (
                "ğŸ¤– I can help you analyze tickets, draft replies, and search the knowledge base. "
                "Type 'help' for all commands."
            )


# ---------- REPL RUNNER ----------

def run_agent_chatbot():
    bot = AgentSupportChatbot()
    print("ğŸ¯ === AGENT SUPPORT ASSISTANT ===")
    print("ğŸ’¡ Type 'help' for commands or 'quit' to exit")
    print("=" * 50, "\n")
    print(bot.get_agent_dashboard(), "\n")
    while True:
        try:
            agent_input = input("ğŸ§‘â€ğŸ’¼ Agent: ").strip()
            if not agent_input:
                continue
            if agent_input.lower() == "quit":
                print("\nğŸ‘‹ Agent session ended. Good luck with your tickets!")
                break
            print("\nğŸ¤– Assistant:\n" + bot.chat(agent_input) + "\n")
        except (EOFError, KeyboardInterrupt):
            print("\n\nğŸ‘‹ Session interrupted. Goodbye!")
            break
        except Exception as exc:
            print(f"\nâŒ Error: {exc}\n")


if __name__ == "__main__":
    run_agent_chatbot()



"""Enhanced Agent Support Chatbot - Firebase Integration
Compatible with Customer Chatbot for seamless ticket management
"""
from __future__ import annotations
import datetime as dt
from typing import Dict, List, Optional
import json
import time

# Firebase imports (install: pip install firebase-admin)
try:
    import firebase_admin
    from firebase_admin import credentials, firestore
    FIREBASE_AVAILABLE = True
except ImportError:
    FIREBASE_AVAILABLE = False
    print("âš ï¸  Firebase not installed. Run: pip install firebase-admin")


class EnhancedAgentChatbot:
    """Agent Support System with Firebase Integration"""

    def __init__(self, firebase_config_path: Optional[str] = None):
        # Initialize Firebase
        self.db = self._init_firebase(firebase_config_path)

        # Enhanced E-commerce Knowledge Base
        self.knowledge_base = self._load_knowledge_base()

        # Ticket status cache for performance
        self.ticket_cache = {}
        self.last_cache_update = None

    def _init_firebase(self, config_path: Optional[str] = None) -> Optional[firestore.Client]:
        """Initialize Firebase connection"""
        if not FIREBASE_AVAILABLE:
            return None

        try:
            if not firebase_admin._apps:
                if config_path:
                    cred = credentials.Certificate(config_path)
                    firebase_admin.initialize_app(cred)
                else:
                    firebase_admin.initialize_app()
            return firestore.client()
        except Exception as e:
            print(f"âš ï¸  Firebase init failed: {e}")
            return None

    def _load_knowledge_base(self) -> Dict:
        """Comprehensive e-commerce knowledge base"""
        return {
            "order_issues": {
                "delivery_delay": {
                    "solution": "1. Check tracking status\n2. Contact shipping partner\n3. Offer expedited replacement\n4. Provide compensation if over 48h delay",
                    "escalation": "high_priority_delayed_orders",
                    "response_template": "I sincerely apologize for the delivery delay. I'm immediately escalating this to our shipping team and will ensure you receive your order within 24 hours with expedited shipping at no extra cost."
                },
                "wrong_item": {
                    "solution": "1. Immediate replacement shipment\n2. Prepaid return label\n3. No need to wait for return\n4. Express shipping upgrade",
                    "escalation": "fulfillment_team",
                    "response_template": "I apologize for the fulfillment error. I'm shipping the correct item immediately via express delivery. You'll receive a prepaid return label for the incorrect item - no rush to return it."
                },
                "damaged_package": {
                    "solution": "1. Photo documentation\n2. Immediate replacement\n3. Carrier claim filing\n4. Upgraded packaging for replacement",
                    "escalation": "quality_assurance",
                    "response_template": "I'm sorry your package arrived damaged. I'm sending a replacement immediately with enhanced packaging. Could you please share photos of the damage for our quality team?"
                }
            },
            "billing_issues": {
                "duplicate_charge": {
                    "solution": "1. Verify transaction logs\n2. Process immediate refund\n3. Check payment gateway\n4. Prevent future occurrences",
                    "escalation": "finance_team",
                    "response_template": "I see the duplicate charge on your account. I'm processing the refund immediately - you'll see the credit within 2-3 business days. I'm also adding a note to prevent this in the future."
                },
                "failed_payment": {
                    "solution": "1. Check payment method\n2. Verify billing info\n3. Try alternative payment\n4. Manual order processing if needed",
                    "escalation": "payment_specialist",
                    "response_template": "Let's resolve this payment issue quickly. I can help you update your payment method or process the order manually. Your cart items are saved and secure."
                }
            },
            "product_issues": {
                "defective_item": {
                    "solution": "1. Quality assessment\n2. Immediate replacement\n3. No-return policy for defects\n4. Report to manufacturing",
                    "escalation": "product_quality",
                    "response_template": "I apologize for receiving a defective product. I'm sending a replacement immediately - no need to return the defective item. This helps us improve our quality control."
                }
            },
            "account_issues": {
                "login_problems": {
                    "solution": "1. Password reset\n2. Account verification\n3. Security check\n4. Alternative access methods",
                    "escalation": "security_team",
                    "response_template": "I'll help you regain access to your account securely. I'm sending a password reset link and will verify your identity to ensure account security."
                }
            }
        }

    def get_live_tickets(self, filters: Dict = None) -> List[Dict]:
        """Fetch real-time tickets from Firebase"""
        if not self.db:
            return self._get_demo_tickets()

        try:
            query = self.db.collection('support_tickets')

            # Apply filters
            if filters:
                if 'status' in filters:
                    query = query.where('status', '==', filters['status'])
                if 'priority' in filters:
                    query = query.where('priority', '==', filters['priority'])
                if 'category' in filters:
                    query = query.where('category', '==', filters['category'])

            # Get recent tickets first
            query = query.order_by('created_at', direction=firestore.Query.DESCENDING).limit(50)

            tickets = []
            for doc in query.stream():
                ticket_data = doc.to_dict()
                ticket_data['id'] = doc.id

                # Convert timestamps
                if 'created_at' in ticket_data and hasattr(ticket_data['created_at'], 'timestamp'):
                    ticket_data['created_at'] = dt.datetime.fromtimestamp(ticket_data['created_at'].timestamp())

                tickets.append(ticket_data)

            # Update cache
            self.ticket_cache = {t['id']: t for t in tickets}
            self.last_cache_update = dt.datetime.now()

            return tickets

        except Exception as e:
            print(f"âŒ Firebase error: {e}")
            return self._get_demo_tickets()

    def _get_demo_tickets(self) -> List[Dict]:
        """Demo tickets when Firebase unavailable"""
        now = dt.datetime.now()
        return [
            {
                "id": "TKT1701234567",
                "status": "open",
                "priority": "high",
                "category": "delivery_issue",
                "user_message": "Order #ORD789 hasn't arrived - it's 3 days late!",
                "summary": "Delivery delay complaint",
                "created_at": now - dt.timedelta(hours=2),
                "customer_sentiment": "frustrated",
                "session_id": "session_1701234567",
                "needs_human_review": True
            },
            {
                "id": "TKT1701234568",
                "status": "open",
                "priority": "medium",
                "category": "billing_issue",
                "user_message": "I was charged twice for my order",
                "summary": "Duplicate billing charge",
                "created_at": now - dt.timedelta(hours=4),
                "customer_sentiment": "concerned",
                "session_id": "session_1701234568",
                "needs_human_review": False
            },
            {
                "id": "TKT1701234569",
                "status": "open",
                "priority": "low",
                "category": "product_issue",
                "user_message": "The headphones I received don't work properly",
                "summary": "Defective product report",
                "created_at": now - dt.timedelta(hours=6),
                "customer_sentiment": "neutral",
                "session_id": "session_1701234569",
                "needs_human_review": False
            }
        ]

    def analyze_ticket(self, ticket_id: str) -> Dict:
        """Enhanced ticket analysis with AI insights"""
        tickets = self.get_live_tickets()
        ticket = next((t for t in tickets if t['id'] == ticket_id), None)

        if not ticket:
            return {"error": "Ticket not found"}

        # Get knowledge base recommendations
        category = ticket.get('category', '')
        issue_type = self._detect_issue_type(ticket.get('user_message', ''))

        knowledge = self.knowledge_base.get(category, {}).get(issue_type, {})

        analysis = {
            "ticket_id": ticket_id,
            "priority": ticket.get('priority', 'medium'),
            "category": category,
            "issue_type": issue_type,
            "customer_sentiment": ticket.get('customer_sentiment', 'neutral'),
            "estimated_resolution": self._get_resolution_time(ticket),
            "escalation_needed": ticket.get('needs_human_review', False),
            "suggested_solution": knowledge.get('solution', 'Custom solution required'),
            "response_template": knowledge.get('response_template', ''),
            "escalation_team": knowledge.get('escalation', 'general_support'),
            "similar_tickets": self._find_similar_tickets(ticket),
            "customer_history": self._get_customer_context(ticket),
            "urgency_score": self._calculate_urgency(ticket)
        }

        return analysis

    def _detect_issue_type(self, message: str) -> str:
        """Simple keyword-based issue detection"""
        message_lower = message.lower()

        # Delivery issues
        if any(word in message_lower for word in ['late', 'delay', 'not arrived', 'missing']):
            return 'delivery_delay'
        if any(word in message_lower for word in ['wrong item', 'incorrect', 'different']):
            return 'wrong_item'
        if any(word in message_lower for word in ['damaged', 'broken', 'crushed']):
            return 'damaged_package'

        # Billing issues
        if any(word in message_lower for word in ['charged twice', 'duplicate', 'double charge']):
            return 'duplicate_charge'
        if any(word in message_lower for word in ['payment failed', 'card declined']):
            return 'failed_payment'

        # Product issues
        if any(word in message_lower for word in ['defective', 'not working', 'broken']):
            return 'defective_item'

        # Account issues
        if any(word in message_lower for word in ['login', 'password', 'account']):
            return 'login_problems'

        return 'general_inquiry'

    def _get_resolution_time(self, ticket: Dict) -> str:
        """Smart resolution time estimation"""
        priority = ticket.get('priority', 'medium')
        category = ticket.get('category', '')

        base_times = {
            'high': 2,
            'medium': 6,
            'low': 24
        }

        # Category adjustments
        if category == 'billing_issue':
            base_times = {k: v//2 for k, v in base_times.items()}  # Faster for billing
        elif category == 'technical_issue':
            base_times = {k: v*2 for k, v in base_times.items()}   # Slower for technical

        hours = base_times.get(priority, 6)
        return f"{hours} hours" if hours < 24 else f"{hours//24} days"

    def _calculate_urgency(self, ticket: Dict) -> int:
        """Calculate urgency score (1-10)"""
        score = 5  # Base score

        # Priority adjustment
        priority_scores = {'low': -2, 'medium': 0, 'high': 3}
        score += priority_scores.get(ticket.get('priority', 'medium'), 0)

        # Sentiment adjustment
        sentiment_scores = {'happy': -1, 'neutral': 0, 'concerned': 1, 'frustrated': 2, 'angry': 3}
        score += sentiment_scores.get(ticket.get('customer_sentiment', 'neutral'), 0)

        # Time-based urgency
        if 'created_at' in ticket:
            hours_old = (dt.datetime.now() - ticket['created_at']).total_seconds() / 3600
            if hours_old > 24:
                score += 2
            elif hours_old > 8:
                score += 1

        return max(1, min(10, score))

    def _find_similar_tickets(self, ticket: Dict) -> List[str]:
        """Find similar tickets for pattern recognition"""
        similar = []
        current_category = ticket.get('category', '')

        for cached_ticket in self.ticket_cache.values():
            if (cached_ticket.get('category') == current_category and
                cached_ticket['id'] != ticket['id']):
                similar.append(cached_ticket['id'])

        return similar[:3]  # Return top 3

    def _get_customer_context(self, ticket: Dict) -> Dict:
        """Get customer context from session/history"""
        session_id = ticket.get('session_id', '')

        # In a real implementation, this would query customer history
        return {
            "session_tickets": 1,
            "total_tickets": 1,
            "customer_tier": "standard",
            "previous_issues": []
        }

    def draft_response(self, ticket_id: str, response_type: str = "full") -> str:
        """Generate professional response drafts"""
        analysis = self.analyze_ticket(ticket_id)

        if "error" in analysis:
            return "âŒ Cannot draft response - ticket not found"

        template = analysis.get('response_template', '')

        if response_type == "acknowledgment":
            return f"Thank you for contacting us regarding ticket {ticket_id}. I understand your concern and I'm here to help resolve this issue quickly."

        elif response_type == "solution":
            return template or "I'm working on a solution for your issue and will have an update for you shortly."

        elif response_type == "follow_up":
            return f"I wanted to follow up on ticket {ticket_id} to ensure everything has been resolved to your satisfaction. Please let me know if you need any additional assistance."

        else:  # full response
            acknowledgment = self.draft_response(ticket_id, "acknowledgment")
            solution = self.draft_response(ticket_id, "solution")
            follow_up = self.draft_response(ticket_id, "follow_up")

            return f"{acknowledgment}\n\n{solution}\n\n{follow_up}"

    def get_agent_dashboard(self) -> str:
        """Real-time agent dashboard"""
        tickets = self.get_live_tickets()

        # Calculate metrics
        open_tickets = [t for t in tickets if t.get('status') == 'open']
        high_priority = [t for t in open_tickets if t.get('priority') == 'high']
        needs_review = [t for t in open_tickets if t.get('needs_human_review', False)]

        # Response time calculation
        if open_tickets:
            avg_age_hours = sum(
                (dt.datetime.now() - t.get('created_at', dt.datetime.now())).total_seconds() / 3600
                for t in open_tickets
            ) / len(open_tickets)
        else:
            avg_age_hours = 0

        dashboard_lines = [
            "ğŸ¯ === AGENT DASHBOARD ===",
            f"ğŸ“Š Tickets: {len(tickets)} total | {len(open_tickets)} open",
            f"ğŸ”¥ High Priority: {len(high_priority)}",
            f"âš ï¸  Needs Review: {len(needs_review)}",
            f"â±  Avg Age: {avg_age_hours:.1f} hours",
            f"ğŸ”„ Last Update: {dt.datetime.now().strftime('%H:%M:%S')}",
            "",
            "ğŸš¨ URGENT TICKETS:"
        ]

        # Show top 5 urgent tickets
        urgent_tickets = sorted(
            [t for t in open_tickets if t.get('priority') == 'high'],
            key=lambda x: self._calculate_urgency(x),
            reverse=True
        )[:5]

        for ticket in urgent_tickets:
            urgency = self._calculate_urgency(ticket)
            dashboard_lines.append(
                f"â€¢ {ticket['id']}: {ticket.get('summary', 'No summary')[:40]}... (Urgency: {urgency}/10)"
            )

        return "\n".join(dashboard_lines)

    def update_ticket_status(self, ticket_id: str, new_status: str, notes: str = "") -> bool:
        """Update ticket status in Firebase"""
        if not self.db:
            print(f"ğŸ“ [DEMO] Ticket {ticket_id} â†’ {new_status}")
            return True

        try:
            doc_ref = self.db.collection('support_tickets').document(ticket_id)
            update_data = {
                'status': new_status,
                'updated_at': firestore.SERVER_TIMESTAMP,
                'agent_notes': notes
            }

            if new_status == 'resolved':
                update_data['resolved_at'] = firestore.SERVER_TIMESTAMP

            doc_ref.update(update_data)

            # Update cache
            if ticket_id in self.ticket_cache:
                self.ticket_cache[ticket_id]['status'] = new_status

            return True

        except Exception as e:
            print(f"âŒ Update failed: {e}")
            return False

    def search_knowledge(self, query: str) -> List[Dict]:
        """Enhanced knowledge search"""
        results = []
        query_lower = query.lower()

        for category, issues in self.knowledge_base.items():
            for issue_type, details in issues.items():
                score = 0

                # Check solution text
                if query_lower in details.get('solution', '').lower():
                    score += 3

                # Check category/issue type
                if query_lower in f"{category} {issue_type}".lower():
                    score += 2

                if score > 0:
                    results.append({
                        'id': f"{category}_{issue_type}",
                        'title': f"{category.replace('_', ' ').title()} - {issue_type.replace('_', ' ').title()}",
                        'content': details.get('solution', ''),
                        'template': details.get('response_template', ''),
                        'escalation': details.get('escalation', ''),
                        'relevance_score': score
                    })

        return sorted(results, key=lambda x: x['relevance_score'], reverse=True)

    def chat(self, agent_input: str) -> str:
        """Enhanced chat interface"""
        cmd = agent_input.strip().lower()
        parts = agent_input.strip().split()

        if cmd.startswith('analyze ') and len(parts) >= 2:
            ticket_id = parts[1].upper()
            analysis = self.analyze_ticket(ticket_id)

            if "error" in analysis:
                return f"âŒ {analysis['error']}"

            return f"""
ğŸ” === TICKET ANALYSIS: {analysis['ticket_id']} ===
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Priority: {analysis['priority'].upper()} | Urgency Score: {analysis['urgency_score']}/10
ğŸ“‚ Category: {analysis['category'].replace('_', ' ').title()}
ğŸ”§ Issue Type: {analysis['issue_type'].replace('_', ' ').title()}
ğŸ˜Ÿ Sentiment: {analysis['customer_sentiment'].title()}
â±  Est. Resolution: {analysis['estimated_resolution']}
ğŸš¨ Escalation: {'YES' if analysis['escalation_needed'] else 'NO'} â†’ {analysis['escalation_team']}

ğŸ’¡ SOLUTION STEPS:
{analysis['suggested_solution']}

ğŸ­ RESPONSE TEMPLATE:
{analysis['response_template']}

ğŸ”— Similar Tickets: {len(analysis['similar_tickets'])} found
            """.strip()

        elif cmd.startswith('draft ') and len(parts) >= 2:
            ticket_id = parts[1].upper()
            response_type = parts[2] if len(parts) > 2 else "full"

            draft = self.draft_response(ticket_id, response_type)
            return f"ğŸ“ === DRAFT RESPONSE ({response_type.upper()}) ===\n\n{draft}"

        elif cmd.startswith('update ') and len(parts) >= 3:
            ticket_id = parts[1].upper()
            new_status = parts[2]
            notes = ' '.join(parts[3:]) if len(parts) > 3 else ""

            success = self.update_ticket_status(ticket_id, new_status, notes)
            return f"{'âœ…' if success else 'âŒ'} Ticket {ticket_id} {'updated' if success else 'update failed'}"

        elif cmd.startswith('search ') and len(parts) >= 2:
            query = ' '.join(parts[1:])
            results = self.search_knowledge(query)

            if not results:
                return f"âŒ No knowledge articles found for '{query}'"

            output = [f"ğŸ” === KNOWLEDGE SEARCH: '{query}' ===\n"]
            for result in results[:3]:
                output.append(f"ğŸ“„ {result['title']}")
                output.append(f"ğŸ’¡ {result['content'][:150]}...")
                output.append("")

            return "\n".join(output)

        elif cmd in ['dashboard', 'dash']:
            return self.get_agent_dashboard()

        elif cmd == 'help':
            return """
ğŸ¤– === ENHANCED AGENT COMMANDS ===
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ analyze [TICKET_ID] - Deep ticket analysis with AI insights
â€¢ draft [TICKET_ID] [type] - Generate response (full|acknowledgment|solution|follow_up)
â€¢ update [TICKET_ID] [status] [notes] - Update ticket status
â€¢ search [query] - Search knowledge base
â€¢ dashboard - Real-time agent dashboard
â€¢ help - Show this help
â€¢ quit - Exit
            """.strip()

        else:
            return "ğŸ¤– I'm your enhanced agent assistant! Type 'help' for commands or 'dashboard' to see current tickets."


def run_enhanced_agent_chatbot():
    """Run the enhanced agent chatbot"""
    print("ğŸ¯ === ENHANCED AGENT SUPPORT SYSTEM ===")
    print("ğŸ”¥ Firebase Integration | AI-Powered Analysis | Real-time Dashboard")
    print("=" * 60)

    # Initialize chatbot
    try:
        bot = EnhancedAgentChatbot()
        print("âœ… System initialized successfully!")
    except Exception as e:
        print(f"âŒ Initialization failed: {e}")
        return

    print("\nğŸ’¡ Type 'help' for commands or 'dashboard' to start")
    print("ğŸ”„ Connecting to live ticket feed...\n")

    # Show initial dashboard
    print(bot.get_agent_dashboard())
    print("\n" + "="*60 + "\n")

    while True:
        try:
            agent_input = input("ğŸ§‘â€ğŸ’¼ Agent: ").strip()

            if not agent_input:
                continue

            if agent_input.lower() == 'quit':
                print("\nğŸ‘‹ Agent session ended. Great work!")
                break

            print("\nğŸ¤– Assistant:")
            response = bot.chat(agent_input)
            print(response)
            print("\n" + "-"*40 + "\n")

        except (EOFError, KeyboardInterrupt):
            print("\n\nğŸ‘‹ Session interrupted. Goodbye!")
            break
        except Exception as e:
            print(f"\nâŒ Error: {e}\n")


if __name__ == "__main__":
    run_enhanced_agent_chatbot()



"""Enhanced Agent Support Chatbot - Firebase Integration
Compatible with Customer Chatbot for seamless ticket management
"""
from __future__ import annotations
import datetime as dt
from typing import Dict, List, Optional
import json
import time

# Firebase imports (install: pip install firebase-admin)
try:
    import firebase_admin
    from firebase_admin import credentials, firestore
    FIREBASE_AVAILABLE = True
except ImportError:
    FIREBASE_AVAILABLE = False
    print("âš ï¸  Firebase not installed. Run: pip install firebase-admin")


class EnhancedAgentChatbot:
    """Agent Support System with Firebase Integration"""

    def __init__(self, firebase_config_path: Optional[str] = None):
        # Initialize attributes first to prevent AttributeError
        self.db = None
        self.ticket_cache = {}
        self.last_cache_update = None

        # Initialize Firebase (safe initialization)
        try:
            self.db = self._init_firebase(firebase_config_path)
        except Exception as e:
            print(f"âš ï¸  Firebase initialization failed: {e}")
            self.db = None

        # Enhanced E-commerce Knowledge Base
        self.knowledge_base = self._load_knowledge_base()

    def _init_firebase(self, config_path: Optional[str] = None) -> Optional[firestore.Client]:
        """Initialize Firebase connection"""
        if not FIREBASE_AVAILABLE:
            return None

        try:
            if not firebase_admin._apps:
                if config_path:
                    cred = credentials.Certificate(config_path)
                    firebase_admin.initialize_app(cred)
                else:
                    firebase_admin.initialize_app()
            return firestore.client()
        except Exception as e:
            print(f"âš ï¸  Firebase init failed: {e}")
            return None

    def _load_knowledge_base(self) -> Dict:
        """Comprehensive e-commerce knowledge base"""
        return {
            "order_issues": {
                "delivery_delay": {
                    "solution": "1. Check tracking status\n2. Contact shipping partner\n3. Offer expedited replacement\n4. Provide compensation if over 48h delay",
                    "escalation": "high_priority_delayed_orders",
                    "response_template": "I sincerely apologize for the delivery delay. I'm immediately escalating this to our shipping team and will ensure you receive your order within 24 hours with expedited shipping at no extra cost."
                },
                "wrong_item": {
                    "solution": "1. Immediate replacement shipment\n2. Prepaid return label\n3. No need to wait for return\n4. Express shipping upgrade",
                    "escalation": "fulfillment_team",
                    "response_template": "I apologize for the fulfillment error. I'm shipping the correct item immediately via express delivery. You'll receive a prepaid return label for the incorrect item - no rush to return it."
                },
                "damaged_package": {
                    "solution": "1. Photo documentation\n2. Immediate replacement\n3. Carrier claim filing\n4. Upgraded packaging for replacement",
                    "escalation": "quality_assurance",
                    "response_template": "I'm sorry your package arrived damaged. I'm sending a replacement immediately with enhanced packaging. Could you please share photos of the damage for our quality team?"
                }
            },
            "billing_issues": {
                "duplicate_charge": {
                    "solution": "1. Verify transaction logs\n2. Process immediate refund\n3. Check payment gateway\n4. Prevent future occurrences",
                    "escalation": "finance_team",
                    "response_template": "I see the duplicate charge on your account. I'm processing the refund immediately - you'll see the credit within 2-3 business days. I'm also adding a note to prevent this in the future."
                },
                "failed_payment": {
                    "solution": "1. Check payment method\n2. Verify billing info\n3. Try alternative payment\n4. Manual order processing if needed",
                    "escalation": "payment_specialist",
                    "response_template": "Let's resolve this payment issue quickly. I can help you update your payment method or process the order manually. Your cart items are saved and secure."
                }
            },
            "product_issues": {
                "defective_item": {
                    "solution": "1. Quality assessment\n2. Immediate replacement\n3. No-return policy for defects\n4. Report to manufacturing",
                    "escalation": "product_quality",
                    "response_template": "I apologize for receiving a defective product. I'm sending a replacement immediately - no need to return the defective item. This helps us improve our quality control."
                }
            },
            "account_issues": {
                "login_problems": {
                    "solution": "1. Password reset\n2. Account verification\n3. Security check\n4. Alternative access methods",
                    "escalation": "security_team",
                    "response_template": "I'll help you regain access to your account securely. I'm sending a password reset link and will verify your identity to ensure account security."
                }
            }
        }

    def get_live_tickets(self, filters: Dict = None) -> List[Dict]:
        """Fetch real-time tickets from Firebase"""
        # Always check if db exists and is properly initialized
        if not self.db:
            return self._get_demo_tickets()

        try:
            query = self.db.collection('support_tickets')

            # Apply filters
            if filters:
                if 'status' in filters:
                    query = query.where('status', '==', filters['status'])
                if 'priority' in filters:
                    query = query.where('priority', '==', filters['priority'])
                if 'category' in filters:
                    query = query.where('category', '==', filters['category'])

            # Get recent tickets first
            query = query.order_by('created_at', direction=firestore.Query.DESCENDING).limit(50)

            tickets = []
            for doc in query.stream():
                ticket_data = doc.to_dict()
                ticket_data['id'] = doc.id

                # Convert timestamps
                if 'created_at' in ticket_data and hasattr(ticket_data['created_at'], 'timestamp'):
                    ticket_data['created_at'] = dt.datetime.fromtimestamp(ticket_data['created_at'].timestamp())

                tickets.append(ticket_data)

            # Update cache
            self.ticket_cache = {t['id']: t for t in tickets}
            self.last_cache_update = dt.datetime.now()

            return tickets

        except Exception as e:
            print(f"âŒ Firebase error: {e}")
            return self._get_demo_tickets()

    def _get_demo_tickets(self) -> List[Dict]:
        """Demo tickets when Firebase unavailable"""
        now = dt.datetime.now()
        return [
            {
                "id": "TKT1701234567",
                "status": "open",
                "priority": "high",
                "category": "delivery_issue",
                "user_message": "Order #ORD789 hasn't arrived - it's 3 days late!",
                "summary": "Delivery delay complaint",
                "created_at": now - dt.timedelta(hours=2),
                "customer_sentiment": "frustrated",
                "session_id": "session_1701234567",
                "needs_human_review": True
            },
            {
                "id": "TKT1701234568",
                "status": "open",
                "priority": "medium",
                "category": "billing_issue",
                "user_message": "I was charged twice for my order",
                "summary": "Duplicate billing charge",
                "created_at": now - dt.timedelta(hours=4),
                "customer_sentiment": "concerned",
                "session_id": "session_1701234568",
                "needs_human_review": False
            },
            {
                "id": "TKT1701234569",
                "status": "open",
                "priority": "low",
                "category": "product_issue",
                "user_message": "The headphones I received don't work properly",
                "summary": "Defective product report",
                "created_at": now - dt.timedelta(hours=6),
                "customer_sentiment": "neutral",
                "session_id": "session_1701234569",
                "needs_human_review": False
            }
        ]

    def analyze_ticket(self, ticket_id: str) -> Dict:
        """Enhanced ticket analysis with AI insights"""
        tickets = self.get_live_tickets()
        ticket = next((t for t in tickets if t['id'] == ticket_id), None)

        if not ticket:
            return {"error": "Ticket not found"}

        # Get knowledge base recommendations
        category = ticket.get('category', '')
        issue_type = self._detect_issue_type(ticket.get('user_message', ''))

        knowledge = self.knowledge_base.get(category, {}).get(issue_type, {})

        analysis = {
            "ticket_id": ticket_id,
            "priority": ticket.get('priority', 'medium'),
            "category": category,
            "issue_type": issue_type,
            "customer_sentiment": ticket.get('customer_sentiment', 'neutral'),
            "estimated_resolution": self._get_resolution_time(ticket),
            "escalation_needed": ticket.get('needs_human_review', False),
            "suggested_solution": knowledge.get('solution', 'Custom solution required'),
            "response_template": knowledge.get('response_template', ''),
            "escalation_team": knowledge.get('escalation', 'general_support'),
            "similar_tickets": self._find_similar_tickets(ticket),
            "customer_history": self._get_customer_context(ticket),
            "urgency_score": self._calculate_urgency(ticket)
        }

        return analysis

    def _detect_issue_type(self, message: str) -> str:
        """Simple keyword-based issue detection"""
        message_lower = message.lower()

        # Delivery issues
        if any(word in message_lower for word in ['late', 'delay', 'not arrived', 'missing']):
            return 'delivery_delay'
        if any(word in message_lower for word in ['wrong item', 'incorrect', 'different']):
            return 'wrong_item'
        if any(word in message_lower for word in ['damaged', 'broken', 'crushed']):
            return 'damaged_package'

        # Billing issues
        if any(word in message_lower for word in ['charged twice', 'duplicate', 'double charge']):
            return 'duplicate_charge'
        if any(word in message_lower for word in ['payment failed', 'card declined']):
            return 'failed_payment'

        # Product issues
        if any(word in message_lower for word in ['defective', 'not working', 'broken']):
            return 'defective_item'

        # Account issues
        if any(word in message_lower for word in ['login', 'password', 'account']):
            return 'login_problems'

        return 'general_inquiry'

    def _get_resolution_time(self, ticket: Dict) -> str:
        """Smart resolution time estimation"""
        priority = ticket.get('priority', 'medium')
        category = ticket.get('category', '')

        base_times = {
            'high': 2,
            'medium': 6,
            'low': 24
        }

        # Category adjustments
        if category == 'billing_issue':
            base_times = {k: v//2 for k, v in base_times.items()}  # Faster for billing
        elif category == 'technical_issue':
            base_times = {k: v*2 for k, v in base_times.items()}   # Slower for technical

        hours = base_times.get(priority, 6)
        return f"{hours} hours" if hours < 24 else f"{hours//24} days"

    def _calculate_urgency(self, ticket: Dict) -> int:
        """Calculate urgency score (1-10)"""
        score = 5  # Base score

        # Priority adjustment
        priority_scores = {'low': -2, 'medium': 0, 'high': 3}
        score += priority_scores.get(ticket.get('priority', 'medium'), 0)

        # Sentiment adjustment
        sentiment_scores = {'happy': -1, 'neutral': 0, 'concerned': 1, 'frustrated': 2, 'angry': 3}
        score += sentiment_scores.get(ticket.get('customer_sentiment', 'neutral'), 0)

        # Time-based urgency
        if 'created_at' in ticket:
            hours_old = (dt.datetime.now() - ticket['created_at']).total_seconds() / 3600
            if hours_old > 24:
                score += 2
            elif hours_old > 8:
                score += 1

        return max(1, min(10, score))

    def _find_similar_tickets(self, ticket: Dict) -> List[str]:
        """Find similar tickets for pattern recognition"""
        similar = []
        current_category = ticket.get('category', '')

        for cached_ticket in self.ticket_cache.values():
            if (cached_ticket.get('category') == current_category and
                cached_ticket['id'] != ticket['id']):
                similar.append(cached_ticket['id'])

        return similar[:3]  # Return top 3

    def _get_customer_context(self, ticket: Dict) -> Dict:
        """Get customer context from session/history"""
        session_id = ticket.get('session_id', '')

        # In a real implementation, this would query customer history
        return {
            "session_tickets": 1,
            "total_tickets": 1,
            "customer_tier": "standard",
            "previous_issues": []
        }

    def draft_response(self, ticket_id: str, response_type: str = "full") -> str:
        """Generate professional response drafts"""
        analysis = self.analyze_ticket(ticket_id)

        if "error" in analysis:
            return "âŒ Cannot draft response - ticket not found"

        template = analysis.get('response_template', '')

        if response_type == "acknowledgment":
            return f"Thank you for contacting us regarding ticket {ticket_id}. I understand your concern and I'm here to help resolve this issue quickly."

        elif response_type == "solution":
            return template or "I'm working on a solution for your issue and will have an update for you shortly."

        elif response_type == "follow_up":
            return f"I wanted to follow up on ticket {ticket_id} to ensure everything has been resolved to your satisfaction. Please let me know if you need any additional assistance."

        else:  # full response
            acknowledgment = self.draft_response(ticket_id, "acknowledgment")
            solution = self.draft_response(ticket_id, "solution")
            follow_up = self.draft_response(ticket_id, "follow_up")

            return f"{acknowledgment}\n\n{solution}\n\n{follow_up}"

    def get_agent_dashboard(self) -> str:
        """Real-time agent dashboard"""
        tickets = self.get_live_tickets()

        # Calculate metrics
        open_tickets = [t for t in tickets if t.get('status') == 'open']
        high_priority = [t for t in open_tickets if t.get('priority') == 'high']
        needs_review = [t for t in open_tickets if t.get('needs_human_review', False)]

        # Response time calculation
        if open_tickets:
            avg_age_hours = sum(
                (dt.datetime.now() - t.get('created_at', dt.datetime.now())).total_seconds() / 3600
                for t in open_tickets
            ) / len(open_tickets)
        else:
            avg_age_hours = 0

        dashboard_lines = [
            "ğŸ¯ === AGENT DASHBOARD ===",
            f"ğŸ“Š Tickets: {len(tickets)} total | {len(open_tickets)} open",
            f"ğŸ”¥ High Priority: {len(high_priority)}",
            f"âš ï¸  Needs Review: {len(needs_review)}",
            f"â±  Avg Age: {avg_age_hours:.1f} hours",
            f"ğŸ”„ Last Update: {dt.datetime.now().strftime('%H:%M:%S')}",
            "",
            "ğŸš¨ URGENT TICKETS:"
        ]

        # Show top 5 urgent tickets
        urgent_tickets = sorted(
            [t for t in open_tickets if t.get('priority') == 'high'],
            key=lambda x: self._calculate_urgency(x),
            reverse=True
        )[:5]

        for ticket in urgent_tickets:
            urgency = self._calculate_urgency(ticket)
            dashboard_lines.append(
                f"â€¢ {ticket['id']}: {ticket.get('summary', 'No summary')[:40]}... (Urgency: {urgency}/10)"
            )

        return "\n".join(dashboard_lines)

    def update_ticket_status(self, ticket_id: str, new_status: str, notes: str = "") -> bool:
        """Update ticket status in Firebase"""
        if not self.db:
            print(f"ğŸ“ [DEMO] Ticket {ticket_id} â†’ {new_status}")
            return True

        try:
            doc_ref = self.db.collection('support_tickets').document(ticket_id)
            update_data = {
                'status': new_status,
                'updated_at': firestore.SERVER_TIMESTAMP,
                'agent_notes': notes
            }

            if new_status == 'resolved':
                update_data['resolved_at'] = firestore.SERVER_TIMESTAMP

            doc_ref.update(update_data)

            # Update cache
            if ticket_id in self.ticket_cache:
                self.ticket_cache[ticket_id]['status'] = new_status

            return True

        except Exception as e:
            print(f"âŒ Update failed: {e}")
            return False

    def search_knowledge(self, query: str) -> List[Dict]:
        """Enhanced knowledge search"""
        results = []
        query_lower = query.lower()

        for category, issues in self.knowledge_base.items():
            for issue_type, details in issues.items():
                score = 0

                # Check solution text
                if query_lower in details.get('solution', '').lower():
                    score += 3

                # Check category/issue type
                if query_lower in f"{category} {issue_type}".lower():
                    score += 2

                if score > 0:
                    results.append({
                        'id': f"{category}_{issue_type}",
                        'title': f"{category.replace('_', ' ').title()} - {issue_type.replace('_', ' ').title()}",
                        'content': details.get('solution', ''),
                        'template': details.get('response_template', ''),
                        'escalation': details.get('escalation', ''),
                        'relevance_score': score
                    })

        return sorted(results, key=lambda x: x['relevance_score'], reverse=True)

    def chat(self, agent_input: str) -> str:
        """Enhanced chat interface"""
        cmd = agent_input.strip().lower()
        parts = agent_input.strip().split()

        if cmd.startswith('analyze ') and len(parts) >= 2:
            ticket_id = parts[1].upper()
            analysis = self.analyze_ticket(ticket_id)

            if "error" in analysis:
                return f"âŒ {analysis['error']}"

            return f"""
ğŸ” === TICKET ANALYSIS: {analysis['ticket_id']} ===
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ¯ Priority: {analysis['priority'].upper()} | Urgency Score: {analysis['urgency_score']}/10
ğŸ“‚ Category: {analysis['category'].replace('_', ' ').title()}
ğŸ”§ Issue Type: {analysis['issue_type'].replace('_', ' ').title()}
ğŸ˜Ÿ Sentiment: {analysis['customer_sentiment'].title()}
â±  Est. Resolution: {analysis['estimated_resolution']}
ğŸš¨ Escalation: {'YES' if analysis['escalation_needed'] else 'NO'} â†’ {analysis['escalation_team']}

ğŸ’¡ SOLUTION STEPS:
{analysis['suggested_solution']}

ğŸ­ RESPONSE TEMPLATE:
{analysis['response_template']}

ğŸ”— Similar Tickets: {len(analysis['similar_tickets'])} found
            """.strip()

        elif cmd.startswith('draft ') and len(parts) >= 2:
            ticket_id = parts[1].upper()
            response_type = parts[2] if len(parts) > 2 else "full"

            draft = self.draft_response(ticket_id, response_type)
            return f"ğŸ“ === DRAFT RESPONSE ({response_type.upper()}) ===\n\n{draft}"

        elif cmd.startswith('update ') and len(parts) >= 3:
            ticket_id = parts[1].upper()
            new_status = parts[2]
            notes = ' '.join(parts[3:]) if len(parts) > 3 else ""

            success = self.update_ticket_status(ticket_id, new_status, notes)
            return f"{'âœ…' if success else 'âŒ'} Ticket {ticket_id} {'updated' if success else 'update failed'}"

        elif cmd.startswith('search ') and len(parts) >= 2:
            query = ' '.join(parts[1:])
            results = self.search_knowledge(query)

            if not results:
                return f"âŒ No knowledge articles found for '{query}'"

            output = [f"ğŸ” === KNOWLEDGE SEARCH: '{query}' ===\n"]
            for result in results[:3]:
                output.append(f"ğŸ“„ {result['title']}")
                output.append(f"ğŸ’¡ {result['content'][:150]}...")
                output.append("")

            return "\n".join(output)

        elif cmd in ['dashboard', 'dash']:
            return self.get_agent_dashboard()

        elif cmd == 'help':
            return """
ğŸ¤– === ENHANCED AGENT COMMANDS ===
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
â€¢ analyze [TICKET_ID] - Deep ticket analysis with AI insights
â€¢ draft [TICKET_ID] [type] - Generate response (full|acknowledgment|solution|follow_up)
â€¢ update [TICKET_ID] [status] [notes] - Update ticket status
â€¢ search [query] - Search knowledge base
â€¢ dashboard - Real-time agent dashboard
â€¢ help - Show this help
â€¢ quit - Exit
            """.strip()

        else:
            return "ğŸ¤– I'm your enhanced agent assistant! Type 'help' for commands or 'dashboard' to see current tickets."


def run_enhanced_agent_chatbot():
    """Run the enhanced agent chatbot"""
    print("ğŸ¯ === ENHANCED AGENT SUPPORT SYSTEM ===")
    print("ğŸ”¥ Firebase Integration | AI-Powered Analysis | Real-time Dashboard")
    print("=" * 60)

    # Initialize chatbot with proper error handling
    try:
        bot = EnhancedAgentChatbot()
        print("âœ… System initialized successfully!")

        # Test basic functionality
        print("ğŸ”„ Testing system components...")
        test_tickets = bot.get_live_tickets()
        print(f"âœ… Found {len(test_tickets)} demo tickets")

    except Exception as e:
        print(f"âŒ Initialization failed: {e}")
        print("ğŸ›   Trying basic initialization...")
        try:
            # Minimal initialization for demo mode
            bot = EnhancedAgentChatbot()
            print("âœ… Basic system ready!")
        except Exception as e2:
            print(f"âŒ Complete failure: {e2}")
            return

    print("\nğŸ’¡ Type 'help' for commands or 'dashboard' to start")
    print("ğŸ”„ Connecting to live ticket feed...\n")

    # Show initial dashboard with error handling
    try:
        print(bot.get_agent_dashboard())
        print("\n" + "="*60 + "\n")
    except Exception as e:
        print(f"âš ï¸  Dashboard error: {e}")
        print("ğŸ® System ready - try 'help' command\n")

    while True:
        try:
            agent_input = input("ğŸ§‘â€ğŸ’¼ Agent: ").strip()

            if not agent_input:
                continue

            if agent_input.lower() == 'quit':
                print("\nğŸ‘‹ Agent session ended. Great work!")
                break

            print("\nğŸ¤– Assistant:")
            response = bot.chat(agent_input)
            print(response)
            print("\n" + "-"*40 + "\n")

        except (EOFError, KeyboardInterrupt):
            print("\n\nğŸ‘‹ Session interrupted. Goodbye!")
            break
        except Exception as e:
            print(f"\nâŒ Error: {e}")
            print("ğŸ’¡ Try 'help' for available commands\n")


if __name__ == "__main__":
    run_enhanced_agent_chatbot()





"""FRONTEND"""



import subprocess
import time
from pyngrok import ngrok
import streamlit as st # Import streamlit directly in the main script

# Replace 'YOUR_AUTHTOKEN' with your actual ngrok authtoken
# Get your authtoken from https://dashboard.ngrok.com/get-started/your-authtoken
# IMPORTANT: Replace "YOUR_AUTHTOKEN" with your actual token
ngrok.set_auth_token("2xbFEEwOudtzz7bH3035AqoVE5d_7gC4fvBSAKoY9MVofKCBH")

# Write Streamlit app code to app.py
streamlit_code = """
import streamlit as st

def main():
    st.set_page_config(page_title="Chatbot Interface", layout="centered")
    st.title("Welcome")

    with st.form(key='login_form'):
        user_type = st.selectbox("Select User Type:", ["User", "Company"])
        email = st.text_input("Email:")
        submit = st.form_submit_button("Submit")

    if submit:
        if not email:
            st.error("Please enter an email address.")
            return

        if user_type == "User":
            st.header("User Chatbot")
            st.write(f"Welcome, {email}! Ask your queries below:")
        else:
            st.header("Company Chatbot")
            st.write(f"Welcome, {email}! Analyze your interactions below:")

        query = st.text_area("Type your query here...")
        if st.button("Send"):
            if query.strip():
                st.success("This is a placeholder response.")
            else:
                st.warning("Please enter a query.")

if __name__ == "__main__":
    main()
"""

with open("app.py", "w") as f:
    f.write(streamlit_code)

# Start Streamlit app in a subprocess
# Use "streamlit run app.py" command directly
streamlit_process = subprocess.Popen(["streamlit", "run", "app.py"])

# Give Streamlit time to start
time.sleep(5)

# Create an ngrok tunnel to the streamlit port
# ngrok.set_auth_token must be called before ngrok.connect()
public_url = ngrok.connect(8501).public_url
print(f"Your Streamlit app is live at: {public_url}")

print("Press Ctrl+C to stop.")

try:
    streamlit_process.wait()
except KeyboardInterrupt:
    print("Stopping server and tunnel...")
    streamlit_process.terminate()
    ngrok.disconnect(public_url)
    ngrok.kill()