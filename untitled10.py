# -*- coding: utf-8 -*-
"""Untitled10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dQ1X6mvvvz3f7eZ3ZyskO8b97zxxGwIL
"""

!pip install google-generativeai firebase-admin python-dotenv

# First install required packages:
# !pip install google-generativeai firebase-admin python-dotenv

import json
import time
import os
from datetime import datetime
from typing import Dict, List, Optional
import google.generativeai as genai
import firebase_admin
from firebase_admin import credentials, firestore

class GeminiFirebaseChatbot:
    def __init__(self, gemini_api_key: str, firebase_credentials_path: str = None):
        # Initialize Gemini API
        genai.configure(api_key=gemini_api_key)

        # Updated model name - use gemini-1.5-flash or gemini-1.5-pro
        try:
            self.model = genai.GenerativeModel('gemini-1.5-flash')
            print("✅ Using Gemini 1.5 Flash model")
        except Exception as e:
            try:
                self.model = genai.GenerativeModel('gemini-1.5-pro')
                print("✅ Using Gemini 1.5 Pro model")
            except Exception as e2:
                print(f"❌ Error initializing Gemini model: {e2}")
                print("🔍 Available models:")
                # List available models
                try:
                    models = genai.list_models()
                    for model in models:
                        if 'generateContent' in model.supported_generation_methods:
                            print(f"   • {model.name}")
                except:
                    print("   Could not retrieve model list")
                raise Exception("Failed to initialize Gemini model")

        # Initialize Firebase
        if firebase_credentials_path and os.path.exists(firebase_credentials_path):
            cred = credentials.Certificate(firebase_credentials_path)
        else:
            # For demo purposes, using default credentials
            # In production, use proper service account key
            try:
                cred = credentials.ApplicationDefault()
            except:
                print("⚠️  Firebase credentials not found. Using local storage fallback.")
                self.db = None

        if not firebase_admin._apps:
            try:
                if firebase_credentials_path and os.path.exists(firebase_credentials_path):
                    firebase_admin.initialize_app(cred)
                    self.db = firestore.client()
                    print("✅ Firebase connected successfully!")
                else:
                    print("⚠️  Firebase credentials not found. Using local storage fallback.")
                    self.db = None
            except Exception as e:
                print(f"⚠️  Firebase connection failed: {e}")
                print("📝 Using local storage fallback.")
                self.db = None
        else:
            try:
                self.db = firestore.client()
            except:
                self.db = None

        # Local storage fallback
        self.local_tickets = []
        self.messages = []
        self.session_id = f"session_{int(time.time())}"

        # Enhanced Knowledge Base for Gemini context
        self.KNOWLEDGE_BASE = {
            "company_info": {
                "name": "TechStore Pro",
                "shipping_policy": "Standard: 3-5 days ($5.99), Express: 1-2 days ($12.99), Free shipping over $50",
                "return_policy": "30-day return policy for unopened items",
                "contact": "Email: support@techstore.com, Phone: 1-800-TECH-HELP",
                "business_hours": "9AM-9PM EST",
                "website": "techstore.com"
            }
        }

        # Ticket classification system
        self.TICKET_CATEGORIES = {
            "delivery_issue": {"priority": "medium", "emoji": "📦"},
            "product_defect": {"priority": "high", "emoji": "⚠️"},
            "billing_issue": {"priority": "high", "emoji": "💳"},
            "account_issue": {"priority": "medium", "emoji": "👤"},
            "technical_issue": {"priority": "medium", "emoji": "🔧"},
            "general_inquiry": {"priority": "low", "emoji": "❓"}
        }

        # Initialize chat
        self.add_message("assistant", "👋 Hi! I'm your AI Customer Support Assistant powered by Gemini. I can help with orders, returns, billing, and technical issues. What can I help you with today?")

    def add_message(self, role: str, content: str):
        """Add message to conversation history"""
        message = {
            "role": role,
            "content": content,
            "timestamp": datetime.now().isoformat(),
            "session_id": self.session_id
        }
        self.messages.append(message)

    def classify_issue(self, user_message: str) -> Dict:
        """Use Gemini to classify the user's issue"""
        classification_prompt = f"""
        Analyze this customer support message and classify it:
        Message: "{user_message}"

        Return ONLY a JSON object with these fields:
        {{
            "category": "delivery_issue|product_defect|billing_issue|account_issue|technical_issue|general_inquiry",
            "needs_ticket": true/false,
            "urgency": "low|medium|high",
            "summary": "brief summary of the issue"
        }}

        Guidelines:
        - needs_ticket: true if it's a complaint, problem, or requires human intervention
        - needs_ticket: false for simple questions or information requests
        - urgency: high for billing, broken products, security issues
        """

        try:
            response = self.model.generate_content(classification_prompt)
            # Clean the response text and try to parse JSON
            response_text = response.text.strip()

            # Sometimes the response might include markdown code blocks, so clean it
            if response_text.startswith('```json'):
                response_text = response_text.replace('```json', '').replace('```', '').strip()
            elif response_text.startswith('```'):
                response_text = response_text.replace('```', '').strip()

            classification = json.loads(response_text)
            return classification
        except json.JSONDecodeError as e:
            print(f"⚠️  JSON parsing error: {e}")
            print(f"Raw response: {response.text if 'response' in locals() else 'No response'}")
            # Fallback classification
            return {
                "category": "general_inquiry",
                "needs_ticket": False,
                "urgency": "low",
                "summary": "General customer inquiry"
            }
        except Exception as e:
            print(f"⚠️  Classification error: {e}")
            # Fallback classification
            return {
                "category": "general_inquiry",
                "needs_ticket": False,
                "urgency": "low",
                "summary": "General customer inquiry"
            }

    def create_firebase_ticket(self, user_message: str, classification: Dict) -> str:
        """Create and store ticket in Firebase"""
        ticket_data = {
            "id": f"TKT{int(time.time())}",
            "user_message": user_message,
            "category": classification["category"],
            "priority": classification["urgency"],
            "summary": classification["summary"],
            "status": "open",
            "created_at": datetime.now().isoformat(),
            "session_id": self.session_id,
            "needs_human_review": classification["urgency"] == "high"
        }

        try:
            if self.db:
                # Store in Firebase
                doc_ref = self.db.collection('support_tickets').document(ticket_data["id"])
                doc_ref.set(ticket_data)
                print(f"✅ Ticket {ticket_data['id']} saved to Firebase")
            else:
                # Store locally as fallback
                self.local_tickets.append(ticket_data)
                print(f"📝 Ticket {ticket_data['id']} saved locally")

            # Format response
            category_info = self.TICKET_CATEGORIES.get(classification["category"], {"emoji": "🎫"})
            priority_emoji = {"low": "🟢", "medium": "🟡", "high": "🔴"}[classification["urgency"]]

            response_time = {
                "low": "24-48 hours",
                "medium": "4-12 hours",
                "high": "1-4 hours"
            }[classification["urgency"]]

            return f"""
🎫 **Support Ticket Created**

{category_info['emoji']} **Ticket ID:** {ticket_data['id']}
{priority_emoji} **Priority:** {classification['urgency'].title()}
📋 **Category:** {classification['category'].replace('_', ' ').title()}
📝 **Summary:** {classification['summary']}

⏰ **Expected Response Time:** {response_time}
📧 You'll receive updates via email
🔔 Ticket status: Open

We'll get this resolved for you quickly!
            """.strip()

        except Exception as e:
            print(f"❌ Error creating ticket: {e}")
            return "❌ Sorry, there was an error creating your support ticket. Please try again or contact us directly."

    def get_gemini_response(self, user_message: str, classification: Dict) -> str:
        """Get intelligent response from Gemini"""

        # Build context for Gemini
        context = f"""
        You are a friendly, professional customer support AI assistant for {self.KNOWLEDGE_BASE['company_info']['name']}.

        Company Information:
        - Shipping: {self.KNOWLEDGE_BASE['company_info']['shipping_policy']}
        - Returns: {self.KNOWLEDGE_BASE['company_info']['return_policy']}
        - Contact: {self.KNOWLEDGE_BASE['company_info']['contact']}
        - Hours: {self.KNOWLEDGE_BASE['company_info']['business_hours']}
        - Website: {self.KNOWLEDGE_BASE['company_info']['website']}

        Customer's issue classification:
        - Category: {classification['category']}
        - Urgency: {classification['urgency']}
        - Summary: {classification['summary']}

        Guidelines:
        - Be empathetic and helpful
        - Provide specific, actionable solutions
        - Use emojis appropriately
        - Keep responses concise but informative
        - If you can't solve it completely, acknowledge and offer next steps

        Customer message: "{user_message}"

        Provide a helpful response:
        """

        try:
            response = self.model.generate_content(context)
            return response.text.strip()
        except Exception as e:
            print(f"⚠️  Gemini API error: {e}")
            # Fallback response
            return f"I understand you're asking about {classification['summary']}. Let me help you with that! For immediate assistance, you can contact us at {self.KNOWLEDGE_BASE['company_info']['contact']} or visit {self.KNOWLEDGE_BASE['company_info']['website']}."

    def chat(self, user_input: str) -> str:
        """Main chat function with Gemini AI and Firebase integration"""
        # Add user message
        self.add_message("user", user_input)

        print("🤖 Analyzing your message...")

        # Classify the issue using Gemini
        classification = self.classify_issue(user_input)

        response = ""

        # Create ticket if needed
        if classification["needs_ticket"]:
            print("🎫 Creating support ticket...")
            ticket_response = self.create_firebase_ticket(user_input, classification)
            response += ticket_response + "\n\n"

        # Get AI response from Gemini
        print("🧠 Generating response...")
        ai_response = self.get_gemini_response(user_input, classification)
        response += ai_response

        # Add assistant response
        self.add_message("assistant", response)

        return response

    def get_tickets_from_firebase(self) -> List[Dict]:
        """Retrieve tickets from Firebase"""
        tickets = []

        try:
            if self.db:
                # Get tickets from Firebase
                docs = self.db.collection('support_tickets').order_by('created_at', direction=firestore.Query.DESCENDING).limit(20).stream()

                for doc in docs:
                    ticket_data = doc.to_dict()
                    tickets.append(ticket_data)

                print(f"📊 Retrieved {len(tickets)} tickets from Firebase")
            else:
                # Use local tickets
                tickets = sorted(self.local_tickets, key=lambda x: x['created_at'], reverse=True)
                print(f"📝 Retrieved {len(tickets)} tickets from local storage")

        except Exception as e:
            print(f"❌ Error retrieving tickets: {e}")
            tickets = self.local_tickets

        return tickets

    def show_tickets(self):
        """Display support tickets"""
        tickets = self.get_tickets_from_firebase()

        if not tickets:
            print("📋 No support tickets found.\n")
            return

        print("🎫 === SUPPORT TICKETS ===")
        open_tickets = [t for t in tickets if t['status'] == 'open']
        print(f"📊 Total: {len(tickets)} | Open: {len(open_tickets)}")
        print("-" * 60)

        for ticket in tickets[:10]:  # Show last 10 tickets
            category_info = self.TICKET_CATEGORIES.get(ticket['category'], {"emoji": "🎫"})
            priority_emoji = {"low": "🟢", "medium": "🟡", "high": "🔴"}[ticket['priority']]
            status_emoji = "🟢" if ticket['status'] == 'resolved' else "🔴"

            print(f"{category_info['emoji']} #{ticket['id']} - {ticket['summary']}")
            print(f"   {priority_emoji} Priority: {ticket['priority'].title()} | {status_emoji} Status: {ticket['status'].title()}")
            print(f"   📅 Created: {datetime.fromisoformat(ticket['created_at']).strftime('%Y-%m-%d %H:%M')}")
            print(f"   💬 Message: {ticket['user_message'][:50]}...")
            print()

    def show_conversation(self):
        """Display conversation history"""
        print("💬 === CONVERSATION HISTORY ===")
        print("-" * 50)

        for msg in self.messages[-10:]:  # Show last 10 messages
            role_emoji = "🤖" if msg['role'] == 'assistant' else "👤"
            role_name = "Assistant" if msg['role'] == 'assistant' else "You"
            timestamp = datetime.fromisoformat(msg['timestamp']).strftime('%H:%M')

            print(f"{role_emoji} {role_name} ({timestamp}):")
            print(f"   {msg['content'][:100]}...")
            print()

def setup_credentials():
    """Help user set up API credentials"""
    print("🔑 === API SETUP REQUIRED ===")
    print("\n1️⃣  GEMINI API KEY:")
    print("   • Go to https://ai.google.dev/")
    print("   • Get your free API key")
    print("   • Enter it below")

    print("\n2️⃣  FIREBASE SETUP (Optional):")
    print("   • Go to https://console.firebase.google.com/")
    print("   • Create a new project")
    print("   • Enable Firestore Database")
    print("   • Download service account key (optional)")

    print("\n" + "="*50)

    gemini_key = input("🔑 Enter your Gemini API key: ").strip()

    if not gemini_key:
        print("❌ Gemini API key is required!")
        return None, None

    firebase_path = input("🔥 Firebase credentials path (press Enter to skip): ").strip()
    firebase_path = firebase_path if firebase_path else None

    return gemini_key, firebase_path

def run_chatbot():
    """Run the enhanced chatbot"""
    print("🤖 === GEMINI + FIREBASE CUSTOMER SUPPORT ===")

    # Setup credentials
    gemini_key, firebase_path = setup_credentials()
    if not gemini_key:
        return

    try:
        bot = GeminiFirebaseChatbot(gemini_key, firebase_path)
    except Exception as e:
        print(f"❌ Failed to initialize chatbot: {e}")
        return

    print("\n💡 Commands:")
    print("   • Type your questions normally")
    print("   • 'tickets' - View support tickets")
    print("   • 'history' - View conversation history")
    print("   • 'clear' - Clear screen")
    print("   • 'quit' - Exit chatbot")
    print("=" * 50)
    print()

    # Show welcome message
    print("🤖 AI Assistant:")
    print(f"   {bot.messages[0]['content']}")
    print()

    while True:
        try:
            user_input = input("👤 You: ").strip()

            if not user_input:
                continue

            if user_input.lower() == 'quit':
                print("\n👋 Thank you for using our AI Customer Support! Have a great day!")
                break
            elif user_input.lower() == 'tickets':
                print()
                bot.show_tickets()
                continue
            elif user_input.lower() == 'history':
                print()
                bot.show_conversation()
                continue
            elif user_input.lower() == 'clear':
                print("\n" * 50)
                continue

            # Process with AI
            print()
            response = bot.chat(user_input)
            print("🤖 AI Assistant:")
            print(f"   {response}")
            print()

        except KeyboardInterrupt:
            print("\n\n👋 Chat interrupted. Goodbye!")
            break
        except Exception as e:
            print(f"\n❌ Error: {e}")
            print("Please try again.\n")

# Run the enhanced chatbot
if __name__ == "__main__":
    run_chatbot()

AIzaSyAKa5keOakH5hAdLuqe96WyPB38uUkND8o

!pip install google-generativeai firebase-admin python-dotenv flask flask-cors transformers torch

"""Agent Support Chatbot – minimal working prototype
---------------------------------------------------
This file contains a *self‑contained* version of the chatbot you’re building.
It bootstraps a few sample tickets and articles so you can run it immediately
and iterate.  Fill in or swap out the sample data / helper logic as you grow.
"""
from __future__ import annotations
import datetime as dt
from typing import Dict, List


class AgentSupportChatbot:  # ==========================
    """CLI‑style assistant for customer‑support agents"""

    # ---------- CONSTRUCTOR & STATE ----------
    def __init__(self,
                 tickets: List[Dict] | None = None,
                 knowledge_articles: List[Dict] | None = None):
        # 🗂  Ticket & KB storage (replace with DB, API, etc.)
        self.tickets: List[Dict] = tickets if tickets is not None else self._seed_tickets()
        self.knowledge_articles: List[Dict] = (
            knowledge_articles if knowledge_articles is not None else self._seed_articles()
        )

    # ---------- SEED DATA (for demo / testing) ----------
    @staticmethod
    def _seed_tickets() -> List[Dict]:
        now = dt.datetime.now()
        return [
            {
                "id": "TKT0001",
                "status": "open",
                "priority": "high",
                "category": "delivery_issue",
                "customer_sentiment": "frustrated",
                "created": now - dt.timedelta(hours=1),
                "customer_message": "My order hasn't arrived yet and it's already 3 days late!",
            },
            {
                "id": "TKT0002",
                "status": "open",
                "priority": "medium",
                "category": "billing_issue",
                "customer_sentiment": "neutral",
                "created": now - dt.timedelta(hours=5),
                "customer_message": "I think I was charged twice for the same item.",
            },
            {
                "id": "TKT0003",
                "status": "closed",
                "priority": "low",
                "category": "product_defect",
                "customer_sentiment": "angry",
                "created": now - dt.timedelta(days=1, hours=2),
                "customer_message": "The keyboard keys are all sticking after one week of use.",
            },
        ]

    @staticmethod
    def _seed_articles() -> List[Dict]:
        return [
            {
                "id": "ART001",
                "title": "How to Track and Expedite a Delivery",
                "content": "Steps agents should follow when a delivery is delayed...",
                "tags": ["delivery", "tracking", "shipping"],
            },
            {
                "id": "ART002",
                "title": "Processing Refunds for Duplicate Charges",
                "content": "Guide on identifying and refunding duplicate transactions...",
                "tags": ["billing", "refund", "duplicate"],
            },
        ]

    # ---------- RESPONSE TEMPLATES ----------
    def get_solution_template(self, ticket: Dict) -> str:
        """Generate solution template based on ticket category"""
        category = ticket["category"]
        solutions = {
            "delivery_issue": (
                "I've checked your order status and will immediately contact our shipping partner "
                "to expedite your delivery. You should receive an update within 2 hours, and I'll "
                "personally monitor this until resolved."
            ),
            "product_defect": (
                "I've arranged for an immediate replacement to be shipped to you via express "
                "delivery at no charge. You'll receive a prepaid return label for the defective "
                "item, and the replacement should arrive within 1‑2 business days."
            ),
            "billing_issue": (
                "I've reviewed your account and can see the duplicate charge. I'm processing the "
                "refund right now, and you should see the credit back to your account within 2‑3 "
                "business days. I'll send you a confirmation email shortly."
            ),
            "account_issue": (
                "I'll help you regain access to your account right away. I'm sending you a secure "
                "password reset link, and I'll also enable additional security features to protect "
                "your account going forward."
            ),
        }
        return solutions.get(category, (
            "Let me investigate this issue thoroughly and provide you with a complete solution "
            "within the next hour."
        ))

    def get_followup_template(self, ticket: Dict) -> str:
        return (
            "I'll follow up with you personally to ensure everything is resolved to your "
            "satisfaction. If you have any questions or concerns in the meantime, please "
            "don't hesitate to reach out directly."
        )

    # ---------- QUICK UTILITY METHODS ----------
    def get_suggested_actions(self, ticket: Dict) -> List[str]:
        """Very simple rule‑based suggestions; replace with ML or rules engine"""
        base = ["Respond to customer", "Log internal note"]
        if ticket["priority"] == "high":
            base.append("Escalate to Tier‑2 support")
        if ticket["category"] == "billing_issue":
            base.append("Process refund via Stripe dashboard")
        return base

    def get_resolution_time(self, ticket: Dict) -> str:
        """Crude ETA based on priority"""
        return {
            "high": "2 h",
            "medium": "6 h",
            "low": "1 d",
        }.get(ticket["priority"], "6 h")

    # ---------- TICKET SUMMARISER ----------
    def summarize_ticket(self, ticket_id: str) -> str:
        ticket = next((t for t in self.tickets if t["id"] == ticket_id), None)
        if not ticket:
            return "Ticket not found"
        summary = f"""
📋 TICKET SUMMARY: {ticket['id']}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🔴 Priority: {ticket['priority'].upper()}
📂 Category: {ticket['category'].replace('_', ' ').title()}
😟 Customer Sentiment: {ticket['customer_sentiment'].title()}
📅 Created: {ticket['created'].strftime('%Y‑%m‑%d %H:%M')}

📝 Issue: {ticket['customer_message']}

⚡ RECOMMENDED ACTIONS:
{chr(10).join('• '+a for a in self.get_suggested_actions(ticket))}

⏱ Est. Resolution: {self.get_resolution_time(ticket)}
🎯 Escalation: {'YES' if ticket['priority']=='high' else 'NO'}
        """.strip()
        return summary

    # ---------- KNOWLEDGE SEARCH ----------
    def search_knowledge(self, query: str) -> List[Dict]:
        query_lower = query.lower()
        q_tokens = set(query_lower.split())
        results: List[Dict] = []
        for art in self.knowledge_articles:
            score = 0
            if query_lower in art["title"].lower():
                score += 3
            if query_lower in art["content"].lower():
                score += 2
            if q_tokens & set(art["tags"]):
                score += 1
            if score:
                results.append({**art, "relevance_score": score})
        return sorted(results, key=lambda x: x["relevance_score"], reverse=True)

    # ---------- DASHBOARD ----------
    def get_agent_dashboard(self) -> str:
        open_tickets = [t for t in self.tickets if t["status"] == "open"]
        high_priority = [t for t in open_tickets if t["priority"] == "high"]
        avg_resp = "N/A"
        if open_tickets:
            now = dt.datetime.now()
            avg_secs = sum((now - t["created"]).total_seconds() for t in open_tickets) / len(open_tickets)
            avg_resp = f"{avg_secs//60:.0f} minutes"
        dash = [
            "🎯 AGENT DASHBOARD",
            "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━",
            "📊 Tickets Overview:",
            f"• Total Open: {len(open_tickets)}",
            f"• High Priority: {len(high_priority)}",
            f"• Avg Response Time: {avg_resp}",
            "",
            "🔥 URGENT TICKETS:",
        ]
        for t in high_priority[:3]:
            dash.append(f"• {t['id']}: {t['customer_message'][:50]}…")
        return "\n".join(dash)

    # ---------- ANALYSE & DRAFT (stub) ----------
    def analyze_ticket(self, ticket_id: str) -> Dict:
        ticket = next((t for t in self.tickets if t["id"] == ticket_id), None)
        if not ticket:
            return {"error": "Ticket not found"}
        return {
            "ticket_id": ticket_id,
            "priority_level": ticket["priority"],
            "estimated_resolution_time": self.get_resolution_time(ticket),
            "escalation_needed": ticket["priority"] == "high",
            "suggested_actions": self.get_suggested_actions(ticket),
            "relevant_articles": self.search_knowledge(ticket["category"]),
            "customer_context": {
                "approach": ticket["customer_sentiment"],
                "tone": "empathetic & proactive" if ticket["priority"] == "high" else "helpful",
            },
        }

    def draft_response(self, ticket_id: str, response_type: str = "standard") -> str:
        ticket = next((t for t in self.tickets if t["id"] == ticket_id), None)
        if not ticket:
            return "Ticket not found"
        if response_type == "apology":
            return (
                "I'm truly sorry for the inconvenience you've experienced. "
                "I understand how frustrating this must be and appreciate your patience while we resolve it."
            )
        if response_type == "solution":
            return self.get_solution_template(ticket)
        if response_type == "follow_up":
            return self.get_followup_template(ticket)
        # default: include apology + solution + follow‑up
        return "\n\n".join([
            self.draft_response(ticket_id, "apology"),
            self.draft_response(ticket_id, "solution"),
            self.draft_response(ticket_id, "follow_up"),
        ])

    # ---------- CHAT LOOP ----------
    def chat(self, agent_input: str) -> str:
        cmd = agent_input.strip()
        lower = cmd.lower()
        if lower.startswith("analyze "):
            tk = cmd.split(" ", 1)[1].upper()
            analysis = self.analyze_ticket(tk)
            if "error" in analysis:
                return f"❌ {analysis['error']}"
            return f"""
🔍 TICKET ANALYSIS: {analysis['ticket_id']}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚡ Priority: {analysis['priority_level'].upper()}
⏱ Est. Resolution: {analysis['estimated_resolution_time']}
🚨 Escalation Needed: {'YES' if analysis['escalation_needed'] else 'NO'}

💡 SUGGESTED ACTIONS:\n{chr(10).join('• '+a for a in analysis['suggested_actions'])}

📚 RELEVANT ARTICLES:\n{chr(10).join('• '+a['title']+' ('+a['id']+')' for a in analysis['relevant_articles'][:3])}

🎭 CUSTOMER CONTEXT:\n• Sentiment: {analysis['customer_context']['approach']}\n• Recommended Tone: {analysis['customer_context']['tone']}
            """.strip()
        elif lower.startswith("draft "):
            parts = cmd.split(" ", 2)  # draft ID [type]
            if len(parts) < 2:
                return "❌ Usage: draft [TICKET_ID] [type]"
            tk = parts[1].upper()
            rtype = parts[2] if len(parts) > 2 else "standard"
            return f"📝 DRAFT RESPONSE FOR {tk}:\n\n{self.draft_response(tk, rtype)}"
        elif lower.startswith("summarize "):
            tk = cmd.split(" ", 1)[1].upper()
            return self.summarize_ticket(tk)
        elif lower.startswith("search "):
            q = cmd.split(" ", 1)[1]
            res = self.search_knowledge(q)
            if not res:
                return f"❌ No articles found for '{q}'"
            out = [f"🔍 KNOWLEDGE SEARCH RESULTS for '{q}':\n"]
            for a in res[:3]:
                out.append(f"📄 {a['title']} ({a['id']})\n{a['content']}\n")
            return "\n".join(out)
        elif lower in {"dashboard", "dash"}:
            return self.get_agent_dashboard()
        elif lower == "help":
            return (
                "🤖 AGENT ASSISTANT COMMANDS:\n"
                "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n"
                "• analyze [TICKET_ID] – Ticket analysis & suggestions\n"
                "• draft [TICKET_ID] [type] – Draft response (apology|solution|follow_up)\n"
                "• summarize [TICKET_ID] – Ticket summary\n"
                "• search [query] – Search knowledge base\n"
                "• dashboard – View agent dashboard\n"
                "• quit – Exit\n"
            )
        else:
            return (
                "🤖 I can help you analyze tickets, draft replies, and search the knowledge base. "
                "Type 'help' for all commands."
            )


# ---------- REPL RUNNER ----------

def run_agent_chatbot():
    bot = AgentSupportChatbot()
    print("🎯 === AGENT SUPPORT ASSISTANT ===")
    print("💡 Type 'help' for commands or 'quit' to exit")
    print("=" * 50, "\n")
    print(bot.get_agent_dashboard(), "\n")
    while True:
        try:
            agent_input = input("🧑‍💼 Agent: ").strip()
            if not agent_input:
                continue
            if agent_input.lower() == "quit":
                print("\n👋 Agent session ended. Good luck with your tickets!")
                break
            print("\n🤖 Assistant:\n" + bot.chat(agent_input) + "\n")
        except (EOFError, KeyboardInterrupt):
            print("\n\n👋 Session interrupted. Goodbye!")
            break
        except Exception as exc:
            print(f"\n❌ Error: {exc}\n")


if __name__ == "__main__":
    run_agent_chatbot()

"""Enhanced Agent Support Chatbot - Firebase Integration
Compatible with Customer Chatbot for seamless ticket management
"""
from __future__ import annotations
import datetime as dt
from typing import Dict, List, Optional
import json
import time

# Firebase imports (install: pip install firebase-admin)
try:
    import firebase_admin
    from firebase_admin import credentials, firestore
    FIREBASE_AVAILABLE = True
except ImportError:
    FIREBASE_AVAILABLE = False
    print("⚠  Firebase not installed. Run: pip install firebase-admin")


class EnhancedAgentChatbot:
    """Agent Support System with Firebase Integration"""

    def __init__(self, firebase_config_path: Optional[str] = None):
        # Initialize attributes first to prevent AttributeError
        self.db = None
        self.ticket_cache = {}
        self.last_cache_update = None

        # Initialize Firebase (safe initialization)
        try:
            self.db = self._init_firebase(firebase_config_path)
        except Exception as e:
            print(f"⚠  Firebase initialization failed: {e}")
            self.db = None

        # Enhanced E-commerce Knowledge Base
        self.knowledge_base = self._load_knowledge_base()

    def _init_firebase(self, config_path: Optional[str] = None) -> Optional[firestore.Client]:
        """Initialize Firebase connection"""
        if not FIREBASE_AVAILABLE:
            return None

        try:
            if not firebase_admin._apps:
                if config_path:
                    cred = credentials.Certificate(config_path)
                    firebase_admin.initialize_app(cred)
                else:
                    firebase_admin.initialize_app()
            return firestore.client()
        except Exception as e:
            print(f"⚠  Firebase init failed: {e}")
            return None

    def _load_knowledge_base(self) -> Dict:
        """Comprehensive e-commerce knowledge base"""
        return {
            "order_issues": {
                "delivery_delay": {
                    "solution": "1. Check tracking status\n2. Contact shipping partner\n3. Offer expedited replacement\n4. Provide compensation if over 48h delay",
                    "escalation": "high_priority_delayed_orders",
                    "response_template": "I sincerely apologize for the delivery delay. I'm immediately escalating this to our shipping team and will ensure you receive your order within 24 hours with expedited shipping at no extra cost."
                },
                "wrong_item": {
                    "solution": "1. Immediate replacement shipment\n2. Prepaid return label\n3. No need to wait for return\n4. Express shipping upgrade",
                    "escalation": "fulfillment_team",
                    "response_template": "I apologize for the fulfillment error. I'm shipping the correct item immediately via express delivery. You'll receive a prepaid return label for the incorrect item - no rush to return it."
                },
                "damaged_package": {
                    "solution": "1. Photo documentation\n2. Immediate replacement\n3. Carrier claim filing\n4. Upgraded packaging for replacement",
                    "escalation": "quality_assurance",
                    "response_template": "I'm sorry your package arrived damaged. I'm sending a replacement immediately with enhanced packaging. Could you please share photos of the damage for our quality team?"
                }
            },
            "billing_issues": {
                "duplicate_charge": {
                    "solution": "1. Verify transaction logs\n2. Process immediate refund\n3. Check payment gateway\n4. Prevent future occurrences",
                    "escalation": "finance_team",
                    "response_template": "I see the duplicate charge on your account. I'm processing the refund immediately - you'll see the credit within 2-3 business days. I'm also adding a note to prevent this in the future."
                },
                "failed_payment": {
                    "solution": "1. Check payment method\n2. Verify billing info\n3. Try alternative payment\n4. Manual order processing if needed",
                    "escalation": "payment_specialist",
                    "response_template": "Let's resolve this payment issue quickly. I can help you update your payment method or process the order manually. Your cart items are saved and secure."
                }
            },
            "product_issues": {
                "defective_item": {
                    "solution": "1. Quality assessment\n2. Immediate replacement\n3. No-return policy for defects\n4. Report to manufacturing",
                    "escalation": "product_quality",
                    "response_template": "I apologize for receiving a defective product. I'm sending a replacement immediately - no need to return the defective item. This helps us improve our quality control."
                }
            },
            "account_issues": {
                "login_problems": {
                    "solution": "1. Password reset\n2. Account verification\n3. Security check\n4. Alternative access methods",
                    "escalation": "security_team",
                    "response_template": "I'll help you regain access to your account securely. I'm sending a password reset link and will verify your identity to ensure account security."
                }
            }
        }

    def get_live_tickets(self, filters: Dict = None) -> List[Dict]:
        """Fetch real-time tickets from Firebase"""
        if not self.db:
            return self._get_demo_tickets()

        try:
            query = self.db.collection('support_tickets')

            if filters:
                if 'status' in filters:
                    query = query.where('status', '==', filters['status'])
                if 'priority' in filters:
                    query = query.where('priority', '==', filters['priority'])
                if 'category' in filters:
                    query = query.where('category', '==', filters['category'])

            query = query.order_by('created_at', direction=firestore.Query.DESCENDING).limit(50)

            tickets = []
            for doc in query.stream():
                ticket_data = doc.to_dict()
                ticket_data['id'] = doc.id

                if 'created_at' in ticket_data and hasattr(ticket_data['created_at'], 'timestamp'):
                    ticket_data['created_at'] = dt.datetime.fromtimestamp(ticket_data['created_at'].timestamp())

                tickets.append(ticket_data)

            self.ticket_cache = {t['id']: t for t in tickets}
            self.last_cache_update = dt.datetime.now()

            return tickets

        except Exception as e:
            print(f"❌ Firebase error: {e}")
            return self._get_demo_tickets()

    def _get_demo_tickets(self) -> List[Dict]:
        """Demo tickets when Firebase unavailable"""
        now = dt.datetime.now()
        return [
            {
                "id": "TKT1701234567",
                "status": "open",
                "priority": "high",
                "category": "delivery_issue",
                "user_message": "Order #ORD789 hasn't arrived - it's 3 days late!",
                "summary": "Delivery delay complaint",
                "created_at": now - dt.timedelta(hours=2),
                "customer_sentiment": "frustrated",
                "session_id": "session_1701234567",
                "needs_human_review": True
            },
            {
                "id": "TKT1701234568",
                "status": "open",
                "priority": "medium",
                "category": "billing_issue",
                "user_message": "I was charged twice for my order",
                "summary": "Duplicate billing charge",
                "created_at": now - dt.timedelta(hours=4),
                "customer_sentiment": "concerned",
                "session_id": "session_1701234568",
                "needs_human_review": False
            },
            {
                "id": "TKT1701234569",
                "status": "open",
                "priority": "low",
                "category": "product_issue",
                "user_message": "The headphones I received don't work properly",
                "summary": "Defective product report",
                "created_at": now - dt.timedelta(hours=6),
                "customer_sentiment": "neutral",
                "session_id": "session_1701234569",
                "needs_human_review": False
            }
        ]

    def analyze_ticket(self, ticket_id: str) -> Dict:
        """Enhanced ticket analysis with AI insights"""
        tickets = self.get_live_tickets()
        print("Available tickets:", [t['id'] for t in tickets])  # Debug line
        ticket = next((t for t in tickets if t['id'] == ticket_id), None)

        if not ticket:
            return {"error": "Ticket not found"}

        category = ticket.get('category', '')
        issue_type = self._detect_issue_type(ticket.get('user_message', ''))

        knowledge = self.knowledge_base.get(category, {}).get(issue_type, {})

        analysis = {
            "ticket_id": ticket_id,
            "priority": ticket.get('priority', 'medium'),
            "category": category,
            "issue_type": issue_type,
            "customer_sentiment": ticket.get('customer_sentiment', 'neutral'),
            "estimated_resolution": self._get_resolution_time(ticket),
            "escalation_needed": ticket.get('needs_human_review', False),
            "suggested_solution": knowledge.get('solution', 'Custom solution required'),
            "response_template": knowledge.get('response_template', ''),
            "escalation_team": knowledge.get('escalation', 'general_support'),
            "similar_tickets": self._find_similar_tickets(ticket),
            "customer_history": self._get_customer_context(ticket),
            "urgency_score": self._calculate_urgency(ticket)
        }

        return analysis

    def _detect_issue_type(self, message: str) -> str:
        """Simple keyword-based issue detection"""
        message_lower = message.lower()

        if any(word in message_lower for word in ['late', 'delay', 'not arrived', 'missing']):
            return 'delivery_delay'
        if any(word in message_lower for word in ['wrong item', 'incorrect', 'different']):
            return 'wrong_item'
        if any(word in message_lower for word in ['damaged', 'broken', 'crushed']):
            return 'damaged_package'

        if any(word in message_lower for word in ['charged twice', 'duplicate', 'double charge']):
            return 'duplicate_charge'
        if any(word in message_lower for word in ['payment failed', 'card declined']):
            return 'failed_payment'

        if any(word in message_lower for word in ['defective', 'not working', 'broken']):
            return 'defective_item'

        if any(word in message_lower for word in ['login', 'password', 'account']):
            return 'login_problems'

        return 'general_inquiry'

    def _get_resolution_time(self, ticket: Dict) -> str:
        """Smart resolution time estimation"""
        priority = ticket.get('priority', 'medium')
        category = ticket.get('category', '')

        base_times = {
            'high': 2,
            'medium': 6,
            'low': 24
        }

        if category == 'billing_issue':
            base_times = {k: v//2 for k, v in base_times.items()}
        elif category == 'technical_issue':
            base_times = {k: v*2 for k, v in base_times.items()}

        hours = base_times.get(priority, 6)
        return f"{hours} hours" if hours < 24 else f"{hours//24} days"

    def _calculate_urgency(self, ticket: Dict) -> int:
        """Calculate urgency score (1-10)"""
        score = 5

        priority_scores = {'low': -2, 'medium': 0, 'high': 3}
        score += priority_scores.get(ticket.get('priority', 'medium'), 0)

        sentiment_scores = {'happy': -1, 'neutral': 0, 'concerned': 1, 'frustrated': 2, 'angry': 3}
        score += sentiment_scores.get(ticket.get('customer_sentiment', 'neutral'), 0)

        if 'created_at' in ticket:
            hours_old = (dt.datetime.now() - ticket['created_at']).total_seconds() / 3600
            if hours_old > 24:
                score += 2
            elif hours_old > 8:
                score += 1

        return max(1, min(10, score))

    def _find_similar_tickets(self, ticket: Dict) -> List[str]:
        """Find similar tickets for pattern recognition"""
        similar = []
        current_category = ticket.get('category', '')

        for cached_ticket in self.ticket_cache.values():
            if (cached_ticket.get('category') == current_category and
                cached_ticket['id'] != ticket['id']):
                similar.append(cached_ticket['id'])

        return similar[:3]

    def _get_customer_context(self, ticket: Dict) -> Dict:
        """Get customer context from session/history"""
        session_id = ticket.get('session_id', '')

        return {
            "session_tickets": 1,
            "total_tickets": 1,
            "customer_tier": "standard",
            "previous_issues": []
        }

    def draft_response(self, ticket_id: str, response_type: str = "full") -> str:
        """Generate professional response drafts"""
        analysis = self.analyze_ticket(ticket_id)

        if "error" in analysis:
            return "❌ Cannot draft response - ticket not found"

        template = analysis.get('response_template', '')

        if response_type == "acknowledgment":
            return f"Thank you for contacting us regarding ticket {ticket_id}. I understand your concern and I'm here to help resolve this issue quickly."

        elif response_type == "solution":
            return template or "I'm working on a solution for your issue and will have an update for you shortly."

        elif response_type == "follow_up":
            return f"I wanted to follow up on ticket {ticket_id} to ensure everything has been resolved to your satisfaction. Please let me know if you need any additional assistance."

        else:
            acknowledgment = self.draft_response(ticket_id, "acknowledgment")
            solution = self.draft_response(ticket_id, "solution")
            follow_up = self.draft_response(ticket_id, "follow_up")

            return f"{acknowledgment}\n\n{solution}\n\n{follow_up}"

    def get_agent_dashboard(self) -> str:
        """Real-time agent dashboard"""
        tickets = self.get_live_tickets()

        open_tickets = [t for t in tickets if t.get('status') == 'open']
        high_priority = [t for t in open_tickets if t.get('priority') == 'high']
        needs_review = [t for t in open_tickets if t.get('needs_human_review', False)]

        # Fixed datetime handling
        if open_tickets:
            avg_age_hours = 0
            valid_tickets = 0
            for t in open_tickets:
                created_at = t.get('created_at')
                if isinstance(created_at, dt.datetime):
                    avg_age_hours += (dt.datetime.now() - created_at).total_seconds() / 3600
                    valid_tickets += 1
            if valid_tickets > 0:
                avg_age_hours = avg_age_hours / valid_tickets
        else:
            avg_age_hours = 0

        dashboard_lines = [
            "🎯 === AGENT DASHBOARD ===",
            f"📊 Tickets: {len(tickets)} total | {len(open_tickets)} open",
            f"🔥 High Priority: {len(high_priority)}",
            f"⚠  Needs Review: {len(needs_review)}",
            f"⏱  Avg Age: {avg_age_hours:.1f} hours",
            f"🔄 Last Update: {dt.datetime.now().strftime('%H:%M:%S')}",
            "",
            "🚨 URGENT TICKETS:"
        ]

        urgent_tickets = sorted(
            [t for t in open_tickets if t.get('priority') == 'high'],
            key=lambda x: self._calculate_urgency(x),
            reverse=True
        )[:5]

        for ticket in urgent_tickets:
            urgency = self._calculate_urgency(ticket)
            dashboard_lines.append(
                f"• {ticket['id']}: {ticket.get('summary', 'No summary')[:40]}... (Urgency: {urgency}/10)"
            )

        return "\n".join(dashboard_lines)

    def update_ticket_status(self, ticket_id: str, new_status: str, notes: str = "") -> bool:
        """Update ticket status in Firebase"""
        if not self.db:
            print(f"📝 [DEMO] Ticket {ticket_id} → {new_status}")
            return True

        try:
            doc_ref = self.db.collection('support_tickets').document(ticket_id)
            update_data = {
                'status': new_status,
                'updated_at': firestore.SERVER_TIMESTAMP,
                'agent_notes': notes
            }

            if new_status == 'resolved':
                update_data['resolved_at'] = firestore.SERVER_TIMESTAMP

            doc_ref.update(update_data)

            if ticket_id in self.ticket_cache:
                self.ticket_cache[ticket_id]['status'] = new_status

            return True

        except Exception as e:
            print(f"❌ Update failed: {e}")
            return False

    def search_knowledge(self, query: str) -> List[Dict]:
        """Enhanced knowledge search"""
        clean_query = query.replace('[', '').replace(']', '').strip().lower()
        results = []

        for category, issues in self.knowledge_base.items():
            for issue_type, details in issues.items():
                score = 0

                if clean_query in details.get('solution', '').lower():
                    score += 3

                if clean_query in f"{category} {issue_type}".lower():
                    score += 2

                for word in clean_query.split():
                    if word in details.get('solution', '').lower():
                        score += 1

                if score > 0:
                    results.append({
                        'id': f"{category}_{issue_type}",
                        'title': f"{category.replace('', ' ').title()} - {issue_type.replace('', ' ').title()}",
                        'content': details.get('solution', ''),
                        'template': details.get('response_template', ''),
                        'escalation': details.get('escalation', ''),
                        'relevance_score': score
                    })

        return sorted(results, key=lambda x: x['relevance_score'], reverse=True)

    def chat(self, agent_input: str) -> str:
        """Enhanced chat interface"""
        cmd = agent_input.strip().lower()
        parts = agent_input.strip().split()

        if cmd.startswith('analyze ') and len(parts) >= 2:
            ticket_id = parts[1].upper()
            analysis = self.analyze_ticket(ticket_id)

            if "error" in analysis:
                return f"❌ {analysis['error']}"

            return f"""
🔍 === TICKET ANALYSIS: {analysis['ticket_id']} ===
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
🎯 Priority: {analysis['priority'].upper()} | Urgency Score: {analysis['urgency_score']}/10
📂 Category: {analysis['category'].replace('_', ' ').title()}
🔧 Issue Type: {analysis['issue_type'].replace('_', ' ').title()}
😟 Sentiment: {analysis['customer_sentiment'].title()}
⏱  Est. Resolution: {analysis['estimated_resolution']}
🚨 Escalation: {'YES' if analysis['escalation_needed'] else 'NO'} → {analysis['escalation_team']}

💡 SOLUTION STEPS:
{analysis['suggested_solution']}

🎭 RESPONSE TEMPLATE:
{analysis['response_template']}

🔗 Similar Tickets: {len(analysis['similar_tickets'])} found
            """.strip()

        elif cmd.startswith('draft ') and len(parts) >= 2:
            ticket_id = parts[1].upper()
            response_type = parts[2] if len(parts) > 2 else "full"

            draft = self.draft_response(ticket_id, response_type)
            return f"📝 === DRAFT RESPONSE ({response_type.upper()}) ===\n\n{draft}"

        elif cmd.startswith('update ') and len(parts) >= 3:
            ticket_id = parts[1].upper()
            new_status = parts[2]
            notes = ' '.join(parts[3:]) if len(parts) > 3 else ""

            success = self.update_ticket_status(ticket_id, new_status, notes)
            return f"{'✅' if success else '❌'} Ticket {ticket_id} {'updated' if success else 'update failed'}"

        elif cmd.startswith('search'):
            query = agent_input[6:].strip()
            results = self.search_knowledge(query)

            if not results:
                return f"❌ No knowledge articles found for '{query}'"

            output = [f"🔍 === KNOWLEDGE SEARCH: '{query}' ==="]
            for result in results[:3]:
                output.append(f"\n📄 {result['title']}")
                output.append(f"💡 {result['content'][:150]}...")
                output.append(f"📝 Template: {result['template'][:100]}..." if result['template'] else "")

            return "\n".join(output)

        elif cmd in ['dashboard', 'dash']:
            return self.get_agent_dashboard()

        elif cmd == 'help':
            return """
🤖 === ENHANCED AGENT COMMANDS ===
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
• analyze [TICKET_ID] - Deep ticket analysis with AI insights
• draft [TICKET_ID] [type] - Generate response (full|acknowledgment|solution|follow_up)
• update [TICKET_ID] [status] [notes] - Update ticket status
• search [query] - Search knowledge base
• dashboard - Real-time agent dashboard
• help - Show this help
• quit - Exit
            """.strip()

        else:
            return "🤖 I'm your enhanced agent assistant! Type 'help' for commands or 'dashboard' to see current tickets."


def run_enhanced_agent_chatbot():
    """Run the enhanced agent chatbot"""
    print("🎯 === ENHANCED AGENT SUPPORT SYSTEM ===")
    print("🔥 Firebase Integration | AI-Powered Analysis | Real-time Dashboard")
    print("=" * 60)

    try:
        bot = EnhancedAgentChatbot()
        print("✅ System initialized successfully!")

        print("🔄 Testing system components...")
        test_tickets = bot.get_live_tickets()
        print(f"✅ Found {len(test_tickets)} demo tickets")

    except Exception as e:
        print(f"❌ Initialization failed: {e}")
        print("🛠  Trying basic initialization...")
        try:
            bot = EnhancedAgentChatbot()
            print("✅ Basic system ready!")
        except Exception as e2:
            print(f"❌ Complete failure: {e2}")
            return

    print("\n💡 Type 'help' for commands or 'dashboard' to start")
    print("🔄 Connecting to live ticket feed...\n")

    try:
        print(bot.get_agent_dashboard())
        print("\n" + "="*60 + "\n")
    except Exception as e:
        print(f"⚠  Dashboard error: {e}")
        print("🎮 System ready - try 'help' command\n")

    while True:
        try:
            agent_input = input("🧑‍💼 Agent: ").strip()

            if not agent_input:
                continue

            if agent_input.lower() == 'quit':
                print("\n👋 Agent session ended. Great work!")
                break

            print("\n🤖 Assistant:")
            response = bot.chat(agent_input)
            print(response)
            print("\n" + "-"*40 + "\n")

        except (EOFError, KeyboardInterrupt):
            print("\n\n👋 Session interrupted. Goodbye!")
            break
        except Exception as e:
            print(f"\n❌ Error: {e}")
            print("💡 Try 'help' for available commands\n")


if __name__ == "__main__":
    run_enhanced_agent_chatbot()

!pip install firebase-admin





